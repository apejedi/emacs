(ns techno.sequencer2
  (:use [techno.sequencer.at-at :as at])
  ;; (:import (java.util.concurrent
  ;;           ScheduledThreadPoolExecutor
  ;;           ScheduledFuture)
  ;;  )
  )

(defonce ^:private sequencers (atom {}))
(defonce ^:private patterns (atom {}))
(defonce ^:private pool (atom nil))
(defrecord SequenceState [size speed step beat])


(defn get-val-if-ref [x]
  (if (instance? clojure.lang.Atom x)
    @x
    x
    )
  )

(defn play
  "Function to play instruments on the given beat"
  ([cur-beat pattern] (play cur-beat pattern false))
  ([cur-beat pattern wrap]
   (let [beat-actions
         (cond
           (fn? pattern) (pattern cur-beat)
           (map? pattern) (pattern cur-beat)
           (sequential? pattern)
           (if (<= cur-beat (count pattern)) (nth pattern (dec cur-beat))))]
     ;(println (System/currentTimeMillis))
     ;;  (println cur-beat)
     ;; (if (> (count beat-actions) 0)
     ;;   (println "playing "
     ;;            (reduce (fn [a b] (str (to-str a) " " (to-str b) " ")) beat-actions)
     ;;            " for beat " cur-beat))
     (dorun
      (for [[instrument args] (partition 2 beat-actions)]
        (if (not (nil? instrument))
          (let [inst (apply instrument args)]
            (if (and (instance? overtone.studio.inst.Inst instrument) ;;If instrument has a gate argument, set it to 0 after trigger
                     (some #(= (:name %) "gate") (:params instrument)))
              (do
                (at (+ (now)
                       (* (if (>= (.indexOf args :dur) 0)
                            (nth args (inc (.indexOf args :dur)))
                            1
                            ) 1000))
                    (ctl inst :gate 0)
                    ))
              )
            ))))))
  )

(defn- handle-beat-trigger [sequencer beat step]
  (let [
        step-beat (fn [beat step]
                    (let [res (inc (* (dec beat) step))]
                      (cond (=  (mod res (int res)) 0.0)
                           (int res)
                           true res)))
        stepped-beat (step-beat beat step)]
    ;(println "orig " beat " stepped beat " stepped-beat)
    (doseq [[k p] (get @patterns (.getId sequencer))]
      (let [val (get-val-if-ref (p :data))
            wrap (p :wrap)
            size (cond
                   (map? val) (apply max (keys val))
                   (sequential? val) (count val)
                   true 1)
            wrap-beat (fn [beat size]
                        (let [s (+ 1 (/ (- size 1) step))
                              steps (cycle (range 1 (inc s)))
                              w (nth steps (dec beat))]
                          (step-beat w step)
                          )
                        )
            final-beat (if (and wrap (> stepped-beat size))
                         (wrap-beat beat size)
                         stepped-beat)]
        ;(println "playing " k " with beat " final-beat)
        (play final-beat val)
        ))
    )
  )

(defn get-s
  ([speed] (get-s speed 1))
  ([speed step]
   (if (nil? @pool)
     (swap! pool (fn [_] (mk-pool))))
   (let [period (/ 1000 (/ speed step))
         job (at/every period
                       (fn [& args]
                         )
                       @pool {})]
     ))
  )

(defn stop-s [sequencer]
  )

(defn stop []
  (if (not (nil? @pool))
    (stop-and-reset-pool! @pool)
    )
  )

;;Attempt to create a purely java based sequencer
(comment
  Interface:
  get-s create and return sequencer
  add-p add pattern
  rm-p
  set-sp
  set-st
  wrap-p
  )
