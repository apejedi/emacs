;; (package-initialize)
;; (require 'clojure-mode)
;; (require 'cider-eldoc)
(load-file "~/.emacs.d/init.el")

(delete-selection-mode t)
(defun insert-zero ()
  (interactive)
  (insert "0")
  )
(global-undo-tree-mode -1)


(global-set-key (kbd "C-x <right>") 'forward-sexp)
(global-set-key (kbd "C-x <left>") 'backward-sexp)
(global-set-key (kbd "C-x c") 'comment-region)
(global-set-key (kbd "C-x x") 'uncomment-region)
(put 'paredit-forward-delete 'delete-selection 'supersede)
(put 'paredit-backward-delete 'delete-selection 'supersede)
(put 'paredit-newline 'delete-selection t)
(global-set-key (kbd "<kp-insert>") 'insert-zero)
(global-set-key (kbd "C-x <C-right>") 'forward-sexp)
(global-set-key (kbd "C-x <C-left>") 'backward-sexp)
(global-set-key (kbd "C-x <up>") 'beginning-of-buffer)
(global-set-key (kbd "C-x <down>") 'end-of-buffer)
(global-set-key (kbd "C-x <down>") 'end-of-buffer)
(load-file "~/.emacs.d/ctable.el")

(defun re-seq (regexp string)
  "Get a list of all regexp matches in a string"
  (save-match-data
    (let ((pos 0)
          matches)
      (while (string-match regexp string pos)
        (push (match-string 0 string) matches)
        (setq pos (match-end 0)))
      matches)))

(defun mk-live ()
  (interactive)
  (setq *live-p* "(comment \n")
  (setq *start* (mark))
  (setq *end* (point))
  (goto-char *start*)
  (setq *cur-key* nil)
  (setq *temp* *start*)
  (while (< (point) *end*)
    (while (not (= (char-after (point)) 58))
      (goto-char (+ (point) 1))
      )
    (setq *live-p* (concat *live-p* "(do (swap! \n("))
    (setq *temp* (point))
    (while (not (= (char-after (point)) 32))
      (goto-char (+ (point) 1))
      )
    (setq *cur-key* (buffer-substring *temp* (point)))
    (setq *live-p* (concat *live-p* *cur-key*)) ;set key
    (setq *live-p* (concat *live-p* " @sketch)\n (fn [_] \n"))
    (while (not (= (char-after (point)) 40))
      (goto-char (+ (point) 1))
      )
    (setq *temp* (point))
    (forward-sexp)
    (setq *live-p* (concat *live-p* (buffer-substring *temp* (point)))) ;set pattern
    (setq *live-p* (concat *live-p* ")) nil)\n" "(s/set-arg @core/s-player " *cur-key* " :amp 1)\n\n"))
    )
  (setq *live-p* (concat *live-p* ")\n"))
  (kill-new *live-p*)
  )

(defun mk-m-phrase ()
  (interactive)
  (setq *live-p* "(s/m-phrase \n {:refresh 0 :sputter 0 :sputter-amt 0 :reverse 0} \n")
  (setq *start* (mark))
  (setq *end* (point))
  (setq *live-p* (concat *live-p* (buffer-substring *start* *end*) " 0.25)\n"))
  (kill-new *live-p*)
  )


(eval-after-load 'paredit
  '(progn
     (define-key paredit-mode-map (kbd "M-<down>") 'next-line)
     (define-key paredit-mode-map (kbd "M-<up>") 'previous-line)
     (global-set-key (kbd "<C-right>") 'right-word)
     (global-set-key (kbd "C-<right>") 'right-word)
     (global-set-key (kbd "M-)") 'paredit-forward-slurp-sexp)
     ))
;; (require 'package)
;; (add-to-list 'package-archives
;;              '("melpa" . "http://melpa.milkbox.net/packages/")
;;              t)
