* Nodes
** Functions
(fn func [a b] ) form returns function object
allow different arity
(fn func ([a] a)
         ([a b] (+ a b)))
Arity - variable number of args
(defn func [a b & c] [a b c]) any args beyond b aggregated as a sequence and bound to c
e.g. (func 1 2 3) => [1 2 (3)]

complement takes a function and returns "not" implementation
((complement f) x) returns (not (f x))

Use letfn to bind local functions which refer to each other.
let binds them serially

*** Anonymous funcs
#(body %1 %2 %&) %& sequence of optional args


*** Multimethods
Add alternative definitions for classes including concrete ones?
#+BEGIN_SRC clojure
(defmethod print-method clojure.lang.PersistentQueue
  [q, w]
  (print-method '<- w) (print-method (seq q) w) (print-method '-< w))

clojure.lang.PersistentQueue/EMPTY
;=> <-nil-<
#+END_SRC

**** Example
#+BEGIN_SRC clojure
  (defmulti compile-cmd (juxt :os compiler))
  (defmethod compile-cmd [::osx "gcc"] [m]
    (str "/usr/bin/" (get m :c-compiler)))
  (defmethod compile-cmd :default [m]
    (str "Unsure where to locate " (get m :c-compiler)))

                                          ;The dispatch values for the new compile-cmd methods are vectors composed of the results of looking up the :os key and calling the compiler function defined earlier. You can now observe what happens when compile-cmd is called:

  (compile-cmd osx)
                                          ;=> "/usr/bin/gcc"
  (compile-cmd unix)
                                          ;=> "Unsure where to locate cc"

#+END_SRC


***** Juxt
The juxt function is highly useful in defining multimethod dispatch functions.
In a nutshell, juxt takes a bunch of functions and composes them into a function returning a vector of its argument(s) applied to each given function, as shown:
#+BEGIN_SRC clojure
(def each-math (juxt + * - /))
(each-math 2 3)
;=> [5 6 -1 2/3]

#+END_SRC


*** Composition Functions
Use comp to create a function which calls other functions linearly
(def fifth (comp first rest rest rest rest))
(fifth [1 2 3 4 5])
;=> 5


*** Testing
See clojure.test
Functions can be made testable by attaching a function in the meta data
#+BEGIN_SRC clojure
  (defn join
    {:test (fn []
             (assert
              (= (join "," [1 2 3]) "1,3,3")))}
    [sep s]
    (apply str (interpose sep s)))
(use '[clojure.test :as t])
(t/run-tests)
; Testing user
;
; ERROR in (join) (test.clj:646)
; ...
#+END_SRC


*** Partial Functions
partial takes a function and returns with one which is partial application to arguments
((partial + 5) 100 200)
;=> 305


*** Pre,Post Conditions (Contracts)
:pre and :post allows conditions to be set to arguments and return values for testability
Will throw a assertion error on fail

#+BEGIN_SRC clojure
  (defn slope [p1 p2]
    {:pre [(not= p1 p2) (vector? p1) (vector? p2)]
     :post [(float? %)]}
    (/ (-(p2 1) (p1 1))
       (-(p2 0) (p1 0))))
#+END_SRC

Assertions can be decoupled into another function for flexibility
#+BEGIN_SRC clojure
  (defn put-things [m]
    (into m {:meat "beef" :veggie "broccoli"}))
  (put-things {})
                                          ;=> {:meat "beef", :veggie "broccoli"}

  (defn vegan-constraints [f m]
    {:pre [(:veggie m)]
     :post [(:veggie %) (nil? (:meat %))]}
    (f m))
  (vegan-constraints put-things {:veggie "carrot"})
                                          ; java.lang.AssertionError: Assert failed: (nil? (:meat %))
#+END_SRC


*** Tail call optimization
Use recur at the tail end of a looping form to avoid stack overflow errors (only usable for fn, loop)
Tail Call Optimization deallocates resources from the caller knowing the control won't return to it and avoids building up a stack


*** Trampolining
Similar to tail call optimization but involving different functions
Useful for creating finite state machines

E.g. A state machine capable of four states simulating a elevator in a two storey building
#+BEGIN_SRC clojure
  (defn elevator [commands]
    (letfn
        Local functions
        [(ff-open [[cmd & r]]
                                          ;1st floor open
                  "When the elevator is open on the 1st floor
  it can either close or be done."
                  #(case cmd
                     :close (ff-closed r)
                     :done
                     true
                     false))
         (ff-closed [[cmd & r]]
                                          ;1st floor closed
                    "When the elevator is closed on the 1st floor
  it can either open or go up."
                    #(case cmd
                       :open (ff-open r)
                       :up (sf-closed r)
                       false))
         (sf-closed [[cmd & r]]
                                          ;2nd floor closed
                    "When the elevator is closed on the 2nd floor
  it can either go down or open."
                    #(case cmd
                       :down (ff-closed r)
                       :open (sf-open r)
                       false))
         (sf-open [[cmd & r]]
                                          ;2nd floor open
                  "When the elevator is open on the 2nd floor
  it can either close or be done"
                  #(case cmd
                     :close (sf-closed r)
                     :done true
                     false))]
        (trampoline ff-open commands)))

(elevator [:close :open :close :up :open :open :done])
;=> false
(elevator [:close :up :open :close :down :open :done])
;=> true
;; run at your own risk!
(elevator (cycle [:close :open]))
#+END_SRC



** Macros

*** Rules
Dont write a macro if a function will do. Reserve macros to provide syntactic abstractions or create binding forms.

Write an example usage.

Expand your example usage by hand.

Use macroexpand, macroexpand-1, and clojure.walk/macroexpand-all4 liberally to understand how your implementation works.

Experiment at the REPL.

Break complicated macros into smaller functions whenever possible

-> Threads forms, the result of each form is used as first argument
->> the result of each form is used as last argument
#+BEGIN_SRC clojure
(-> (/ 144 12) (/ ,,, 2 3) str keyword list)
;=> (:2)
(-> (/ 144 12) (* ,,, 4 (/ 2 3)) str keyword (list ,,, :33))
;=> (:32 :33)
(->> a (+ 5 ,,,) (let [a 5] ,,,))
;=> 10

#+END_SRC

eval evaluates data structures representing code


*** defmacro
Define a macro (expects a list of forms?)


*** examples
#+BEGIN_SRC clojure
  (defmacro do-until [& clauses]
    (when clauses
      (list `when (first clauses)
            (if (next clauses)
              (second clauses)
              (throw (IllegalArgumentException.
                      "do-until requires an even number of forms")))
            (cons 'do-until (nnext clauses)))))

  (do-until
   (even? 2) (println "Even")
   (odd? 3) (println "Odd")
   (zero? 1) (println "You never see me")
   :lollipop (println "Truthy thing"))
                                          ; Even
                                          ; Odd
                                          ;=> nil

  (require '[clojure.walk :as walk])
  (walk/macroexpand-all '(do-until true (prn 1) false (prn 2)))
                                          ;=> (if true (do (prn 1) (if false (do (prn 2) nil))))
#+END_SRC


** Loops
#+BEGIN_SRC clojure
    (defn sum-down-from [sum x]
      (if (pos? x)
        (recur (+ sum x) (dec x))
        sum))
  (defn sum-down-from [initial-x]
    (loop [sum 0, x initial-x]
      (if (pos? x)
        (recur (+ sum x) (dec x))
        sum)))
  ;Upon entering the loop form, the locals sum and x are initialized, just as they would be for a let.
  ;A recur always loops back to the closest enclosing loop or fn, so in this case itçª¶å†¤l go to the loop. The loop locals are rebound to the values given in recur.
 ; Recur can only occur in the tail position
#+END_SRC

*** Conditionals
Use When to perform side effects (when (cond)
                                   (executes-but-does-not-return)
                                   body)
if-let used for binding vars only when a truthy value is returned
(if-let [res :truthy-thing] (println res))
; :truthy-thing



** Vars
Can be shared among threads?
(def x val) creates root binding, default among all threads

*** Syntax-quote ` or (quote symbol)
Prevents evalutation of subforms like ' but does also auto qualifies symbols
e.g. `map => clojure.core/map

*** unquote ~, selectively evaluate subforms of a ` form
e.g. `(+ 10 ~(* 2 3)) => (clojure.core/+ 10 6)

*** unquote splice ~@, "unpack" sequence
e.g. (let [x '(2 3)] `(1 ~@x)) => (1 2 3)

*** Get unqualified(unbound?) symbol
Auto-gensym
append # to symbol e.g. `potion#


** Protocols
Collection of function signatures
Can be implemented by (extend) (extend-type and (extend-protocol
Equivalent to Interfaces? Can be used to extend core types which interfaces can't

Any protocol methods that are going to be used must be implemented at the same time

*** Example
A stack protocol push, pop peek implemented by a TreeNode type and Vector type
#+BEGIN_SRC clojure
(defprotocol FIXO
(fixo-push [fixo value])
(fixo-pop [fixo])
(fixo-peek [fixo]))

  (extend-type TreeNode
    FIXO
                                          ;Delegate ãƒ to xconj
    (fixo-push [node value]
      (xconj node value))
    (fixo-peek [node]
                                          ;Walk down left nodes
      (if (:l node)
        to find smallest
        (recur (:l node))
                                          ;Build new path down
        (:val node)))
    left to removed item
    (fixo-pop [node]
      (if (:l node)
        (TreeNode. (:val node) (fixo-pop (:l node)) (:r node))
        (:r node))))
  (extend-type clojure.lang.IPersistentVector
    fixo-push is
    FIXO
                                          ;vector's conj
    (fixo-push [vector value]
      (conj vector value))
    (fixo-peek [vector]
                                          ;peek is peek
      (peek vector))
    (fixo-pop [vector]
                                          ;pop is pop
      (pop vector)))

#+END_SRC



** Records
   (defrecord TreeNode [val l r])

This creates a new Java class with a constructor that takes a value for each of the fields listed. It also imports that class into your current namespace so you can easily use it to create new instances.

Here's how to create an instance of the TreeNode record:

(TreeNode. 5 nil nil)
;=> #:user.TreeNode{:val 5, :l nil, :r nil}

*** Caveat
These classes are automatically imported into the same namespace where the defrecord and deftype declarations occur, but not in any other namespace. Instead, you must explicitly import defrecord and deftype classes using the import function or :import namespace declaration:
(ns my-cool-ns
(:import joy.udp.TreeNode))
Loading a namespace via :require or :use wont be enough to import defrecord or deftype


** Declaring/Implementing interfaces
reify used to generate a concrete instance of class implementing a interface/protocol?

definterface same as defprotocol except definterface allows primitive types for arguments and returns
#+BEGIN_SRC clojure
  (definterface ISliceable
    (slice [^int s ^int e])
    (^int sliceCount []))

  (def dumb
    (reify user.ISliceable
      (slice [_ s e] [:empty])
      (sliceCount [_] 42)))

#+END_SRC


** Java Interop

*** Constructing objects
(new java.util.HashMap {"foo" 42 "bar" 9 "baz" "quux"})
or
(java.util.HashMap. {"foo" 42 "bar" 9 "baz" "quux"})


*** Set instance properties
(let [origin (java.awt.Point. 0 0)]
          (set! (.x origin) 15)
          (str origin))
;=> "java.awt.Point[x=15,y=0]"


*** Chain method calls
(.endsWith (.toString (java.util.Date.)) "2010")
or
(.. (java.util.Date.) toString (endsWith "2010"))

if method calls don't return the object, use doto Macro
#+BEGIN_SRC clojure
(doto (java.util.HashMap.)
          (.put "HOME" "/home/me")
          (.put "SRC"  "src")
          (.put "BIN"  "classes"))
#+END_SRC


*** Exceptions
Runtime Exception stored in *e

Sometimes need to catch errors instead of exceptions e.g. (catch Error e "Error Message")

e.g. (.printStacktrace *e)
#+BEGIN_SRC clojure
  (throw (Exception. "I done throwed"))
   ;=> java.lang.Exception: I done throwed
  (defn throw-catch [f]
    (try
       (f)
       (catch ArithmeticException e "No dividing by zero!")
       (catch Exception e (str "You are so bad " (.getMessage e)))
       (finally (println "returning... "))))
#+END_SRC


*** Extending concrete classes anonymously? (Proxies)
proxy used to extend concrete classes
Example web server
#+BEGIN_SRC clojure
(ns joy.web
(:import (com.sun.net.httpserver HttpHandler HttpExchange HttpServer)
         (java.net InetSocketAddress HttpURLConnection)
         (java.io IOException FilterOutputStream)
         (java.util Arrays)))
(defn new-server [port path handler]
                                        ;Create service
  (doto (HttpServer/create (InetSocketAddress. port) 0)
    (.createContext path handler)
    (.setExecutor nil)
    (.start)))
(defn default-handler [txt]
                                        ;Print hello message
  (proxy [HttpHandler] []
    (handle [exchange]
      (.sendResponseHeaders exchange HttpURLConnection/HTTP_OK 0)
      (doto (.getResponseBody exchange)
        (.write (.getBytes txt))
                                        ;Close over txt
        (.close)))))
(def server (new-server 8123
                        "/joy/hello"
                        (default-handler "Hello Cleveland")))

#+END_SRC

**** Dynamically modifying proxies using update-proxy
#+BEGIN_SRC clojure
  (defn make-handler-fn [fltr txt]
    (fn [this exchange]
                                          ;Name explicit this
      (let [b (.getBytes txt)]
        (-> exchange
            .getResponseHeaders
            (.set "Content-Type" "text/html"))
        (.sendResponseHeaders exchange
                              HttpURLConnection/HTTP_OK
                              0)
        (doto (fltr (.getResponseBody exchange))
                                          ;Pass through filter
          (.write b)
          (.close)))))
  (defn change-message
    "Convenience method to change a proxy's output message"
    ([p txt] (change-message p identity txt))
                                          ;Use identity filter
    ([p fltr txt]
       (update-proxy p
                     {"handle" (make-handler-fn fltr txt)})))

#+END_SRC


*** Constructing named classes (gen-class)
#+BEGIN_SRC clojure
  (ns joy.gui.DynaFrame
    (:gen-class
     :name joy.gui.DynaFrame
     :extends javax.swing.JFrame
                                          ;Superclass
     :implements [clojure.lang.IMeta]
                                          ;Interface
     :prefix df-
                                          ;If you don't specify a :prefix, then the default - will be used. 2

     :state state
                                          ;Instance state Constructor
     :init init
                                          ;Init function mapping
     :constructors {[String] [String]}
     :methods [[display [java.awt.Container] void]
                                          ;Public method
               ^{:static true} [version [] String]])
                                          ;Static method
    (:import (javax.swing JFrame JPanel)
             (java.awt BorderLayout Container)))

  (in-ns 'joy.gui.DynaFrame)
  (defn df-init [title]
    [[title] (atom {::title title})])

  (compile 'joy.gui.DynaFrame)

  (defn df-display [this pane]
    (doto this
      (-> .getContentPane .removeAll)
      (.setContentPane (doto (JPanel.)
                         (.add pane BorderLayout/CENTER)))
      (.pack)
      (.setVisible true)))

  (def gui (joy.gui.DynaFrame. "4th"))
  (.display gui (doto (javax.swing.JPanel.)
                  (.add (javax.swing.JLabel. "Charlemagne and Pippin"))))
#+END_SRC


** Namespaces
(ns namespace) creates and switches to the namespace
*ns* contains the current namespace
(in-ns ns) same as ns but does not create mappings for clojure.core

(clojure.core/refer ns) creates mappings for that namespace in the current namespace?

(create-ns ns) creates and returns a namespace object but doesn't switch to it.
(intern) creates mapping

#+BEGIN_SRC clojure
(def b (create-ns 'bonobo))
b
;=> #<Namespace bonobo>
((ns-map b) 'String)
;=> java.lang.String

(intern b 'x 9)
;=> #'bonobo/x
bonobo/x
;=> 9

#+END_SRC

*** Private vars
#+BEGIN_SRC clojure
  (ns hider.ns)
  (defn ^{:private true} answer [] 42)
  (ns seeker.ns
    (:refer hider.ns))
  (answer)
              ; java.lang.Exception: Unable to resolve symbol: answer in this context
#+END_SRC


*** Loading namespace
#+BEGIN_SRC clojure
    (ns joy.req
      (:require clojure.set))

    (ns joy.req-alias
      (:require [clojure.set :as s]))

    (s/intersection #{1 2 3} #{3 4 5})
    ;=> #{3}

 other keywords for :require :rename
  (ns joy.yet-another
    (:refer joy.ch1 :rename {hello hi}))
  (hi)
  ; Hello Cleveland!

:refer same as :use but only works for namespaces that have already been loaded
#+END_SRC


*** Mapping external functions to current namespace
#+BEGIN_SRC clojure
(ns joy.use-ex
  (:use [clojure.string :only [capitalize]]))
#+END_SRC


*** Loading java classes
#+BEGIN_SRC clojure
(ns joy.java
  (:import [java.util HashMap]
           [java.util.concurrent.atomic AtomicLong]))
(HashMap. {"happy?" true})
;=> #<HashMap {happy?=true}>
#+END_SRC


** Destructuring

*** Vector
#+BEGIN_SRC clojure
  (let [range-vec (vec (range 10))
        [a b c & more :as all] range-vec]
    (println "a b c are:" a b c)
    (println "more is:" more)
    (println "all is:" all))
  ; a b c are: 0 1 2
  ; more is: (3 4 5 6 7 8 9)
  ;all is: [0 1 2 3 4 5 6 7 8 9]
#+END_SRC

*** Map

#+BEGIN_SRC clojure
(def guys-name-map
          {:f-name "Guy" :m-name "Lewis" :l-name "Steele"})

(let [{f-name :f-name, m-name :m-name, l-name :l-name} guys-name-map]
          (str l-name ", " f-name " " m-name))

(let [{:keys [f-name m-name l-name]} guys-name-map]
          (str l-name ", " f-name " " m-name))
;for string keys use :strs, for symbol keys :syms

;Use :or to provide defaults

(let [{:keys [title f-name m-name l-name], :or {title "Mr."}} guys-name-map]
  (println title f-name m-name l-name))
; Mr. Guy Lewis Steele

Works similarly with vectors
(let [{first-thing 0, last-thing 3} [1 2 3 4]]
  [first-thing last-thing])
;=> [1 4]

(doseq [[dimension amount] {:width 10, :height 20, :depth 15}]
          (println (str (name dimension) ":") amount "inches"))
        ; width: 10 inches
        ; height: 20 inches
        ; depth: 15 inches
#+END_SRC


** Data types

*** Scalars
**** Rational numbers
Floating types and doubles don't guarantee Distributivity
#+BEGIN_SRC clojure
  (def a 1.0e50)
  (def b -1.0e50)
  (def c 17.0e00)
  (+ (+ a b) c)
  ;=> 17.0
  Associativity should guarantee 17.0 also
  (+ a (+ b c))
  ;=> 0.0
  (let [a (float 0.1)
        b (float 0.2)
        c (float 0.3)]
    (=
     Distributive should
     (* a (+ b c))
     guarantee equality
     (+ (* a b) (* a c))))
  ;=> false
#+END_SRC

Rationals gurantee precise calculations
e.g. 3/4

Rationalize numbers
(rationalize 0.01), (rationalize 1.0e50)
Check if rational (rational? num)

Get components
(numerator num)
(denominator num)


**** Keywords
Always evaluate themselves, provide fast equality checks
Used as map keys (:a {:a "asc" :b "sdc"})
as Function directives, All keywords are truthy
(if asd
   sddsv
 :else dsdv)

(name :keyword) returns string representation
Can be namespace qualified
#+BEGIN_SRC clojure
  (defn do-blowfish [directive]
    (case directive
      :aquarium/blowfish (println "feed the fish")
      :crypto/blowfish (println "encode the message")
      :blowfish (println "not sure what to do")))
  (ns crypto)
  (user/do-blowfish :blowfish)
                                          ; not sure what to do
  (user/do-blowfish ::blowfish)
                                          ; encode the message
  (ns aquarium)
  (user/do-blowfish :blowfish)
                                          ; not sure what to do
  (user/do-blowfish ::blowfish)
                                          ; feed the fish

#+END_SRC


**** Symbols
Used as identifiers
Can be referred with a ' operator to prevent evaluation
(symbol string) returns a symbol optionally namespace qualified
(name symbol) returns string representation of symbol

Can attach meta data to Vars
#+BEGIN_SRC clojure
  (let [x (with-meta 'goat {:ornery true})
        y (with-meta 'goat {:ornery false})]
    [(= x y)
     (identical? x y)
     (meta x)
     (meta y)])
;=> [true false {:ornery true} {:ornery false}]
#+END_SRC


*** Composites


**** Sequences
seq Interface has two methods: first, rest
A sequence is a collection that may contain values that haven't been computed yet

Test if a sequence is empty
(seq []) => nil

rseq returns reversed sequence

***** Vectors
******* Creating, appending
Conversion to vector (vec sequence)
Appending values (into vector sequence)
Typed vectors (vector-of :int) other options include :long, :float, :double, :byte, :short, :boolean
Auto casts any added elements and provides a space advantage?
Each key value pair in Maps is a vector

******* Reading
Accessing elements
(nth vector n)
(get vector n)
(vector n)
All are equivalent but nth will throw a exception when index is out of range
using the vector will throw exception if vector is nil or index out of range

get and nth support default return value e.g. (get [] 9 :default)

subvec to get slice of Vector, optimized for nested operations
(subvec vector start end) start is inclusive and end exclusive

******* Manipulating
assoc inserts elements
(assoc a-to-j 4 "no longer E")
        ;=> [\A \B \C \D "no longer E" \F \G \H \I \J]

replace to find and replace elements
(replace {2 :a, 4 :b} [1 2 3 2 3 4])
        ;=> [1 :a 3 :a 3 :b]

get-in assoc-in, update-in and update-in for modifying nested structures
#+BEGIN_SRC clojure
  (def matrix
    [[1 2 3]
     [4 5 6]
     [7 8 9]])

  (get-in matrix [1 2])
                                          ;=> 6
  (assoc-in matrix [1 2] 'x)
                                          ;=> [[1 2 3] [4 5 x] [7 8 9]]
update-in applies a function to a element
(update-in matrix [1 2] * 100)
        ;=> [[1 2 3] [4 5 600] [7 8 9]]

#+END_SRC

conj , pop and peek for stack operations , More efficient than assoc, dissoc and last
#+BEGIN_SRC clojure
  (def my-stack [1 2 3])
  (peek my-stack)
  ;=> 3
  (pop my-stack)
  ;=> [1 2]
  (conj my-stack 4)
  ;=> [1 2 3 4]
#+END_SRC







***** Lists
Much more suited for queue operations than vectors

conj to prepend values
(conj '(2 3) 1)
;=> (1 2 3)

peek and pop for the rest



***** Lazy Sequences
1 Use the lazy-seq macro at the outermost level of your lazy sequence producing expression(s).
2 If you happen to be consuming another sequence during your operations, then use rest instead of next.
3 Prefer higher-order functions when processing sequences.

(map (iterate func i)) another way to create a lazy seq? when a sequence can be generated by a increasing n
#+BEGIN_SRC clojure
(defn triangle [n]
(/ (* n (+ n 1)) 2))

(def tri-nums (map triangle (iterate inc 1)))

(take 10 tri-nums)
Get first 10
;=> (13 6 10 15 21 2836 45 55)
(take 10 (filter even? tri-nums))
;=> (6 10 28 36 66 78 120 136 190 210)
Get

#+END_SRC

Lazy quick sort
#+BEGIN_SRC clojure
  (defn nom [n] (take n (repeatedly #(rand-int n))))
  (defn sort-parts
    "Lazy, tail-recursive, incremental quicksort. Works against
  and creates partitions based on the pivot, defined as 'work'."
    [work]

    (lazy-seq
  ;  Pull apart work
     (loop [[part & parts] work]
  ;     Define pivot
       (if-let [[pivot & xs] (seq part)]
   ;      comparison fn
         (let [smaller? #(< % pivot)]
           (recur (list*
                   (filter smaller? xs)
  ;                 Work all < pivot
                   pivot
;                   Work pivot itself
                   (remove smaller? xs)
  ;                 Work all > pivot
                   parts)))
  ;       Concat parts
         (when-let [[x & parts] parts]
           (cons x (sort-parts parts)))))))
  ;Sort rest n if more parts
  (defn qsort [xs]
    (sort-parts (list xs)))

#+END_SRC



**** Sets
Collection type which allows only unique elements independent of concrete type
Internally sets are maps in which each element is both key and value

#{[1 2] (1 2)}
;=> #{[1 2]}

(sorted-set args) returns a ordered set

clojure.set used for mathematical set operations
intersection, union and difference

***** Accessing
(#{:a :b :c :d} :c)
;=> :c
(#{:a :b :c :d} :e)
;=> nil


**** Maps
Each key value pair stored as sequence
(seq {:a 1, :b 2})
;=> ([:a 1] [:b 2])

Keys can be of any type including composite types

***** Creating
{key value key value}

From vectors
(into {} [[:a 1] [:b 2]])
;=> {:a 1, :b 2}

(apply hash-map [:a 1 :b 2])
;=> {:a 1, :b 2}

(zipmap [:a :b] [1 2])
;=> {:b 2, :a 1}

sorted-map to create ordered Maps
sorted-map-by to create maps using a user defined comparator function
 (sorted-map-by #(compare (subs %1 1) (subs %2 1)) "bac" 2 "abc" 9)
        ;=> {"bac" 2, "abc" 9}

subseq, rsubseq to walk from a key inside the map

use array-map to preserve insertion order


Generic Iteration
#+BEGIN_SRC clojure
(defn index [coll]
          (cond
            (map? coll) (seq coll)
            (set? coll) (map vector coll coll)
            :else (map vector (iterate inc 0) coll)))

(defn pos [pred coll]
         (for [[i v] (index coll) :when (pred v)] i))

(pos #{3 4} {:a 1 :b 2 :c 3 :d 4})
        ;=> (:c :d)
        (pos even? [2 3 6 7])
        ;=> (0 2)
#+END_SRC


** Regular Expressions
(class #"example")
;=> java.util.regex.Pattern

With flags
#"(?i)exp"

Use re-seq to return sequence of matches

(re-seq #"\w*(\w)" "one-two/three")
;=> (["one" "e"] ["two" "o"] ["three" "e"])


** Lazy Expressions
force, delay macros can be used to create forms which can be lazily evaluated
 #+BEGIN_SRC clojure
   (defn defer-expensive [cheap expensive]
     (if-let [good-enough (force cheap)]
       good-enough
       (force expensive)))

   (defer-expensive (delay :cheap)
     (delay (do (Thread/sleep 5000) :expensive)))
                                           ;=> :cheap
   (defer-expensive (delay false)
     (delay (do (Thread/sleep 5000) :expensive)))
                                           ;=> :expensive
   You can simula

 #+END_SRC


** Ad Hoc Heirarchies
Similar to Prototype inheritance?

#+BEGIN_SRC clojure
  (derive ::osx ::unix)
                                          ;Now the home function works:
  (home osx)
                                          ;=> "/Users"
                                          ;You can query the derivation hierarchy using the functions parents, ancestors, descendants, and isa? as shown:
  (parents ::osx)
                                          ;=> #{:user/unix}

  (ancestors ::osx)
                                          ;=> #{:user/unix}
  (descendants ::unix)
                                          ;=> #{:user/osx}
  (isa? ::osx ::unix)
                                          ;=> true
  (isa? ::unix ::osx)
                                          ;=> false
#+END_SRC


** Parallel computing
Software Transactional memory system.

Similar to database transactions.


*** Ref Types
Every Ref type except Vars are shared and are visible across threads.

| Trait        | Ref | Agent | Atom | Var |
| Coordinated  |  T  |       |      |     | Changes can be made without race conditions
| Asynchronous |     |   T   |      |     | Updates can be deferred and the requesting thread can continue immeditately
| Retriable    |  T  |       |  T   |     | Update is speculative and might be repeated
| Thread-local |     |       |      |  T  | All changes are isolated to one thread

**** Updating Refs
(alter f ref) Starts a transaction on the ref, updating its value

(commute f ref) updates a ref without preserving the pre-transaction value
Using commute is useful as long as the following conditions aren't problematic:
The value you see in-transaction may not be the value that gets committed at commit time.
The function you give to commute will be run at least twice-once to compute the in-transaction value, and again to compute the commit value. It might be run any number of times.


**** Refs
Synchronous and uses transactions

Multipe threads modifying a chess board
#+BEGIN_SRC clojure
  (import '(java.util.concurrent Executors))
  (def *pool* (Executors/newFixedThreadPool
               (+ 2 (.availableProcessors (Runtime/getRuntime)))))
  (defn dothreads! [f & {thread-count :threads
                         exec-count :times
                         :or {thread-count 1 exec-count 1}}]
    (dotimes [t thread-count]
      (.submit *pool* #(dotimes [_ exec-count] (f)))))

  (def initial-board
    [[:-:k :-]
     [:-:-:-]
     [:-:K :-]])
  (defn board-map [f bd]
    (vec (map #(vec (for [s %] (f s))) bd)))

  (defn reset!
    "Resets the board state. Generally these types of functions are a
    bad idea, but matters of page count force our hand."
    []
    (def board (board-map ref initial-board))
    (def to-move (ref [[:K [2 1]] [:k [0 1]]]))
    (def num-moves (ref 0)))

  (def king-moves (partial neighbors
                           [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]] 3))
  (defn good-move? [to enemy-sq]
    (when (not= to enemy-sq) to))
  (defn choose-move [[[mover mpos][_ enemy-pos]]]
    [mover (some #(good-move? % enemy-pos)
                 (shuffle (king-moves mpos)))])

  (defn place [from to] to)
  (defn move-piece [[piece dest] [[_ src] _]] (alter (get-in board dest) place piece) (alter (get-in board src ) place :-) (alter num-moves inc))
                                          ;Place moving piece Empty from square
  (defn update-to-move [move] (alter to-move #(vector (second %) move)))
                                          ;Swap
  (defn make-move [] (dosync
                      (let [move (choose-move @to-move)]
                        (move-piece move @to-move)
                        (update-to-move move))))



  (defn go [move-fn threads times]
    (dothreads! move-fn :threads threads :times times))


  (make-move)
                                          ;=> [[:k [0 1]] [:K [2 0]]]
  (board-map deref board)
                                          ;=> [[:-:k :-] [:-:-:-] [:K :-:-]]
  @num-moves
                                          ;=> 1

  (go make-move 100 100)
  (board-map #(dosync (deref %)) board)
                                          ;=> [[:k :-:-] [:-:-:-] [:K :-:-]]
  @to-move
                                          ;=> [[:k [0 0]] [:K [2 0]]]
  @num-moves
                                          ;=> 10001
#+END_SRC


**** Agents
Allows atomic updates as well but doesn't use transactions? so use when preservation of pre-call state isn't required, asynchronous

#+BEGIN_SRC clojure
  (def log-agent (agent 0))
                                          ;Now we’ll supply an action function to send to log-agent. All action functions take as their first argument the current state of the Agent and can take any number of other arguments that are sent:
  (defn do-log [msg-id message]
    (println msg-id ":" message)
    (inc msg-id))
                                          ;Here msg-id is the state—the first time do-log is sent to the Agent, msg-id will be 0. The return value of the action function will be the new Agent state, incrementing it to 1 after that first action.
                                          ;Now we need to do some work worth logging about, but for this example we’ll just pretend:
  (defn do-step [channel message]
    (Thread/sleep 1)
    (send-off log-agent do-log (str channel message)))
  (defn three-step [channel]
    (do-step channel " ready to begin (step 0)")
    (do-step channel " warming up (step 1)")
    (do-step channel " really getting going now (step 2)")
    (do-step channel " done! (step 3)"))
                                          ;To see how log-agent will correctly queue and serialize the messages, we need to start a few threads, each yammering away at the Agent, shown next:
  (defn all-together-now []
    (dothreads! #(three-step "alpha"))
    (dothreads! #(three-step "beta"))
    (dothreads! #(three-step "omega")))

  (all-together-now)
                                          ; 0 : alpha ready to being (step 0)
                                          ; 1 : omega ready to being (step 0)
                                          ; 2 : beta ready to being (step 0)
                                          ; 3 : alpha warming up (step 1)
                                          ; 4 : alpha really getting going now (step 2)
                                          ; 5 : omega warming up (step 1)
                                          ; 6 : alpha done! (step 3)
                                          ; 7 : omega really getting going now (step 2)
                                          ; 8 : omega done! (step 3)
                                          ; 9 : beta warming up (step 1)
                                          ; 10 : beta really getting going now (step 2)
                                          ; 11 : beta done! (step 3)

#+END_SRC

Use await, or await-for to block calling thread until action on agent is executed.

Use send-off for actions that might block/sleep etc.
Use send for actions that won't.

agent-error to check agents for errors

restart-agent to reset failed/stopped state and optionally clear pending actions

***** Error Handling
#+BEGIN_SRC clojure
  (defn handle-log-error [the-agent the-err]
    (println "An action sent to the log-agent threw " the-err))
  (set-error-handler! log-agent handle-log-error)
  (set-error-mode! log-agent :continue)

  (send log-agent (fn [x] (/ x 0))) ; incorrect
                                          ; An action sent to the log-
  agent threw java.lang.ArithmeticException: Divide by zero
                                          ;=> #<Agent@66200db9: 2501>
  (send log-agent (fn [] 0)) ; also incorrect
                                          ; An action sent to the log-agent threw java.lang.IllegalArgumentException:
                                          ; Wrong number of args passed to: user$eval--820$fn
#+END_SRC


**** Atoms
use Atoms in transactions only when you're certain that an attempt to update its value, performed numerous times, is idempotent.
Aside from the normal use of @ and deref to query an Atom's value, you can also use the mutating functions swap!, compare-and-set!, and reset!

#+BEGIN_SRC clojure
(def *time* (atom 0))
(defn tick [] (swap! *time* inc))
(dothreads! tick :threads 1000 :times 100)
#+END_SRC


*** Futures
future macro creates a reference type which can be asynchronously computed
#+BEGIN_SRC clojure


(require '(clojure [xml :as xml]))
(require '(clojure [zip :as zip]))
(defmulti rss-children class)
(defmethod rss-children String [uri-str]
                                        ;Twitter is online at http://twitter.com. 6
  (-> (xml/parse uri-str)
      zip/xml-zip
      zip/down
      zip/children))

(import '(java.util.regex Pattern))
(defn count-tweet-text-task [txt feed]
  (let [items (rss-children feed)
        re (Pattern/compile (Pattern/quote txt))]
    (count (mapcat #(re-seq re (first %))
                                        ;Get kids Get matches
                   (for [item (filter (comp #{:item} :tag) items)]
                                        ;lFilter non-items
                     (-> item :content first :content))))))

(defmacro as-futures [[a args] & body]
  (let [parts (partition-by #{'=>} body)
        [acts _ [res]] (partition-by #{:as} (first parts))
        [_ _ task] parts]
    `(let [~res (for [~a ~args] (future ~@acts))]
       ~@task)))

(defn tweet-occurrences [tag & feeds]
  (as-futures [feed feeds]
              (count-tweet-text-task tag feed)
              :as results
              =>
              (reduce (fn [total res] (+ total @res))
                      0
                      results)))
                                        ;The as-futures macro builds a sequence of futures named results, enclosing the call to count-tweet-text-task across the unique set of Twitter feeds provided. We then sum the counts returned from the dereferencing of the individual futures, as shown:
(tweet-occurrences "#Clojure"
                   "http://twitter.com/statuses/user_timeline/46130870.rss"
                   "http://twitter.com/statuses/user_timeline/14375110.rss"
                   "http://twitter.com/statuses/user_timeline/5156041.rss"
                   "http://twitter.com/statuses/user_timeline/21439272.rss")
                                        ;=> 22

#+END_SRC


*** Promises
Same as futures but can be explicitly set using deliver function
Only one thread can deliver the promise and the call to dereference is blocking

#+BEGIN_SRC clojure
  (def x (promise))
  (def y (promise))
  (def z (promise))
  (dothreads! #(deliver z (+ @x @y)))
  (dothreads!
   #(do (Thread/sleep 2000) (deliver x 52)))
  (dothreads!
   #(do (Thread/sleep 4000) (deliver y 86)))
  (time @z)
                                          ; "Elapsed time: 3995.414 msecs"
                                          ;=> 138

  (defmacro with-promises [[n tasks _ as] & body]
    (when as
      `(let [tasks# ~tasks
             n# (count tasks#)
             promises# (take n# (repeatedly promise))]
         (dotimes [i# n#]
           (dothreads!
            (fn []
              (deliver (nth promises# i#)
                       ((nth tasks# i#))))))
         (let [~n tasks#
               ~as promises#]
           ~@body))))

  (defrecord TestRun [run passed failed])
  (defn pass [] true)
  (defn fail [] false)
  (defn run-tests [& all-tests]
    (with-promises
      [tests all-tests :as results]
      (into (TestRun. 0 0 0)
            (reduce #(merge-with + %1 %2) {}
                    (for [r results]
                      (if @r
                        {:run 1 :passed 1}
                        {:run 1 :failed 1}))))))
  (run-tests pass fail fail fail pass)
                                          ;=> #:user.TestRun{:run 5, :passed 2, :failed 3
#+END_SRC

Macro to convert callback based call to a blocking call
#+BEGIN_SRC clojure
  (defn tweet-items [k feed]
    (k
     (for [item (filter (comp #{:item} :tag) (rss-children feed))]
       (-> item :content first :content))))

  (tweet-items
   count
   "http://twitter.com/statuses/user_timeline/46130870.rss")
                                          ;=> 16

  (defmacro cps->fn [f k]
    `(fn [& args#]
       (let [p# (promise)]
         (apply ~f (fn [x#] (deliver p# (~k x#))) args#)
         @p#)))


  (def count-items (cps->fn tweet-items count))
  (count-items "http://twitter.com/statuses/user_timeline/46130870.rss")
                                          ;=> 16
#+END_SRC


*** Explicit Locking
locking macro
#+BEGIN_SRC clojure
  (defprotocol SafeArray
    (aset [this i f])
    of functions
    (aget [this i])
    (count [this])
    (seq [this]))

  (defn pummel [a]
    (dothreads! #(dotimes [i (count a)] (aset a i inc)) :threads 100))

  (defn make-safe-array [t sz]
    (let [a (make-array t sz)]

      (reify
        (count [_] (clj/count a))
        (seq [_] (clj/seq a))
        (aget [_ i]
                                          ;aget is locked
          (locking a
            (clj/aget a i)))
        (aset [this i f]
                                          ;aset is locked
          (locking a
            (clj/aset a i (f (aget this i))))))))
                                          ;aset uses aget
  (def A (make-safe-array Integer/TYPE 8))
  (pummel A)

  ;; wait for pummel to terminate
  (seq A)
                                          ;=> (100 100 100 100 100 100 100 100

#+END_SRC



*** pvalues
Executes multiple expressions in parallel and returns a lazy sequence as a result

all seq values within a sliding window 8 are forced, so processing time is limited by the most costly element therein.
Currently, the window size is N+2, where N is the number of CPU cores. But this is an implementation detail, so it's enough to know only that the sliding window exists.
#+BEGIN_SRC clojure
  (defn sleeper [s thing] (Thread/sleep (* 1000 s)) thing)
  (defn pvs [] (pvalues
                (sleeper 2 :1st)
                (sleeper 3 :2nd)
                (keyword "3rd")))
  (-> (pvs) first time)
                                          ; "Elapsed time: 2000.309 msecs"
                                          ;=> :1st
                                          ;The total time cost of accessing the first value in the result of pvs is only the cost of its own calculation. But accessing any subsequent element costs as much as the most expensive element before it, which you can verify by accessing the last element:
  (-> (pvs) last time)
                                          ; "Elapsed time: 4001.435 msecs"
                                          ;=> :3rd

#+END_SRC


*** pmap
Similar to map but function application happens in parallel
#+BEGIN_SRC clojure
  (->> [1 2 3]
       (pmap (comp inc (partial sleeper 2)))
       doall
       time)
                                          ; "Elapsed time: 2000.811 msecs"
                                          ;=> (2 3 4)

#+END_SRC


*** pcalls
Call several functions in parallel without any arguments and return a lazy sequence as a results

#+BEGIN_SRC clojure
  (-> (pcalls
       #(sleeper 2 :1st)
       #(sleeper 3 :2nd)
       #(keyword "3rd"))
      doall
      time)
                                          ; "Elapsed time: 3001.039 msecs"
                                          ;=> (:1st :2nd :3rd)
#+END_SRC


*** Vars
Vars can be named and interned in a namespace
and can provide a thread local value.
Each var has a root binding and acts like a stack when new values are assigned to it.
binding macro can be used to push and pop values from vars
var function to return the var object

#+BEGIN_SRC clojure
(var *read-eval*)
;=> #'clojure.core/*read-eval*

  (defn binding-play []
    (print-read-eval)
    (binding [*read-eval* false]
      (print-read-eval))
    (print-read-eval))
                                          ;This results in the Var temporarily having a thread-local value of false:
  (binding-play)
                                          ; *read-eval* is currently true
                                          ; *read-eval* is currently false
                                          ; *read-eval* is currently true

#+END_SRC

** Performance

*** Type hints
Hints can reduce need for reflection thus increasing speed.
#+BEGIN_SRC clojure
  (set! *warn-on-reflection* true)
                                          ;=> true

  (defn asum-sq [xs]
    (let [dbl (amap xs i ret
                    (* (aget xs i)
                       (aget xs i)))]
      (areduce dbl i ret 0
               (+ ret (aget dbl i)))))

(time (dotimes [_ 10000] (asum-sq (float-array [1 2 3 4 5]))))
; "Elapsed time: 410.539 msecs"

;Change to (defn asum-sq [ ^floats xs]

(time (dotimes [_ 10000] (asum-sq (float-array [1 2 3 4 5]))))
; "Elapsed time: 17.087 msecs"

(.intValue (asum-sq (float-array [1 2 3 4 5])))
; Reflection warning, reference to field intValue can't be resolved.
;=> 55

;Change to (defn ^Float asum-sq [ ^floats xs]

;Hints can also be placed outside of function definitions

(.intValue ^Float (asum-sq (float-array [1 2 3 4 5])))
#+END_SRC
