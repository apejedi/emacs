Application ID
AA006DM9SI

bank statements 12 months
pay slips 12 months
transcript
i-797
i-120
ds-160


* Data Structures
** Trees
Trees are acyclic, undirected, connected graphs

Number of notes in a binary tree of height h,  n = 2^(h+1) - 1
h = floor(log2(n))
Growth rate for search operation ceiling(log2(n)) (AVERAGE CASE)
rate for deletion and addition the same   (AVERAGE CASE)

WORST CASE for all operations O(n)

- Complete binary tree -> when a binary tree of height h has 2^(h+1) - 1 nodes

Traversal methods
- Pre-order root -> left-subtree -> right-subtree
- In-order  left-subtree -> root -> right-subtree (Sorted order)
traverse(node) { // ascending
if (node != NULL) {
    traverse(node->left)
    process(node->data)
    traverse(node->right)
  }
}
- Post-order left-subtree -> right-subtree -> root

*** Binary Trees
External node: node with no children
Internal node: node with exactly two children

 - A binary tree with N internal nodes has N + 1 external nodes.

 - A binary tree with N internal nodes has 2N links: N - 1 links to internal nodes and N + 1 links to external nodes.
 - The level of a node in a tree is one higher than the level of its parent (with the root at level 0).
   The height of a tree is the maximum of the levels of the tree's nodes.
   The path length of a tree is the sum of the levels of all the tree's nodes.
   The internal path length of a binary tree is the sum of the levels of all the tree's internal nodes.
   The external path length of a binary tree is the sum of the levels of all the tree's external nodes.

 - The external path length of any binary tree with N internal nodes is 2N greater than the internal path length.

 - The height of a binary tree with N internal nodes is at least lg N and at most N - 1.

 - The internal path length of a binary tree with N internal nodes is at least N lg(N/4) and at most N(N - 1)/2.


** Graphs
:PROPERTIES:
:CUSTOM_ID: graphs
:END:

G(V,E) -> V set of vertices {v2,v2...} , E set of edges {(v1,v2), (v2,v3)....}

Path -> Vector of vertices <v1, v2, v3...>

Degree(v) -> number of edges radiating from v

Spanning Tree -> A set of edges of size |V| - 1 which connects all vertices

Minimum Spanning Tree -> A set of edges in a weighted graph which connects all vertices and has a minimum weight

*** Attributes
:PROPERTIES:
:CUSTOM_ID: graph_attributes
:END:
- Undirected (v1,v2) == (v2,v1)
- Directed  (v1,v2) != (v2,v1)
- Weighted E = {(v1,v2,weight(v1,v2)),.....}
- Non-simple graphs can have (x,x) edges
                        and multiple occurences of edges between same vertices (Multiedges) distinguished by labels
- Dense  |E| approx= |V|^2
- Sparse |E| approx = |V|
- Embedded G(V,E) is geometric?
- Implicit G is built while traversal e.g. Backtrack searching
- Connected component set of vertices V s.t. All pairs in V have a connecting path
- Strongly connected graph All pairs in V have a connecting path in a directed graph
- Matching a Subset of edges in G such that no two edges share a vertex
- Bipartite/Two-colorable vertices can be divided into sets L and R such that all edges have one vertex in L and other in R
- Residual Graph R(G,f) a directed weighted graph with edges (i,j)  with w(i,j) = c(i,j) - f(i,j) if c(i,j) > f(i,j) and (j,i) with w(j,i) = f(i,j) if f(j,i)>0
   w= weight, f = flow, c = capacity  Used to determine optimality of a newtwork flow graph

- Articulation vertex, a vertex whose removal causes the root and a leaf to be disconnected
Types of articulation vertices
root -> whenever a root has two or more children
bridge -> when earliest_reachable_ancestor[v] = v then both parent[v] and v are articulation vertices
parent -> when earliest_reachable_ancestor[v] = parent[v] then parent[v] is a articulation vertex




*** Adjacency Representations
Matrix
  v1  v2
v1 0  1

v2 1  0

M[v1, v2] = 1, M[v1,v1] = 0

Edge insertion/deletion O(1)
Traversal O(n^2)

List

v1->linked-list of connected nodes
v2->linked-list of connected nodes
...
In a directed graph, the list of edges correspond to vertices where the edge ends starting from edge[v]

Edge insertion/deletion O(d)
Traversal O(m + n) n->vertices, m->edges
#+BEGIN_SRC java
class Graph // ADT interface
  { // implementations and private members hidden
    Graph(int, boolean)
    int V()
    int E()
    boolean directed()
    int insert(Edge)
    void remove(Edge)
    boolean edge(int, int)
    AdjList getAdjList(int)
  }

interface AdjList
  {
    int beg()
    int nxt()
    boolean end()
  }

class Edge
  { int v, w;
    Edge(int v, int w)
      { this.v = v; this.w = w; }
  }

static Edge[] edges(Graph G)
  { int E = 0;
    Edge[] a = new Edge[G.E()];
    for (int v = 0; v < G.V(); v++)
      {
        AdjList A = G.getAdjList(v);
        for (int w = A.beg(); !A.end(); w = A.nxt())
          if (G.directed() || v < w)
            a[E++] = new Edge(v, w);
      }
    return a;
  }


#+END_SRC

** Stacks
pop, push

** Heaps
Binary trees with some constraint for top node (max or min)

- Always filled from the left

- Deletion
  Remove top node, and replace with rightmost leaf node
  Keep swapping with children using max or min property until no swapping is needed

- Addition
  Insert node into the left most leaf position
  Keep swapping with parents using heap property until no swapping is needed

Can be easily represented by an array
For n nodes, node arr[k]->left = arr[2k]
                  arr[k]->right = arr[2k + 1]



** Linked List
search(list *l, x)
if(l==NULL) return NULL
if(l->x==x) return true
return search(l->next, x)

delete(list **l, x)
p = search(l, x)
pred = predecessor(l, x) // Same as search() except test for (l->next)->x == x

pred->next = p->next
free(p)

** Hash Tables
:PROPERTIES:
:CUSTOM_ID: hash_tables
:END:

Hashed Keys usually result in large number
                   |S|-1
sample func H(S) = Sigma x^(|S|-(i+1)) * S[i]
                   i=0

*** Scaling integer/float values into a domain
If the size of table is M and keys fall in 0 to 1
H(k) = M*k

For w bit integers H(k) = k/(2^w) * M //Shift right w bits to divide by 2^w
Or choose M to be prime
and H(k) = k % M


* Algorithms
** Sorting
*** Insertion, Bubble and Selection O(n^2)
Insertion count(arr) = n
- for (i n)
   j = i, v = arr[i]
   while(arr[j-1] > v)
    arr[j] = arr[j-1], j--
   arr[j] = v

Bubble Sort
for(i n)
 for(j n-i)
  if(a[j-1] > a[j]) swap(a[j-1], a[j])

*** HeapSort
Construct a heap with array O(log(n))
Perform deletion and place head node into array O(n)
Total compelxity O(nlog(n)) both average and worst case

*** QuickSort
Patrition array recursively using a point pivot in array while maintaining the property that
elements smaller than pivot element occur before the pivot while elements bigger than pivot occur after

Average case O(nlog(n)) Heuristically faster than heap sort although theoritically same
Worst case  O(n^2)

*** BinSort
Put elements of array in an array of size M (number of keys possible) using their values as keys bin[a[i]] = a[i]
Run through the array ignoring empty values

Complexity O(m+n) m,n might be the deciding factor resulting in O(m) or O(n)

Creates a huge demand for space if M is big

Good for values which fall in a narrow range

*** Radix sort
Specialization of bin sort using a[i] % n as the key instead of a[i]

** Searching
*** Dijkstra's algorithm
- Used to find shortest path from one node to another in a acyclic spanning tree
- Calculating shortest path of one node leads to discovery of shortes paths of all other nodes

S - Set of vertices whose shortest paths to s have been calculated
V-S - Set of vertices whose paths haven't been calculated

d - array of best estimates from each vertex to s
pi - array of predecessors for each vertex from s

Algorithm -> While V-S is not empty
             1) sort vertices in V-S based on cost estimate to source s
             2) Add closest vertex u to S
             3) Relax vertices in V-S connected to u
Relax(u, v) ->
If cost(s,v) > cost(s,u) + cost(u,v)
cost(s,v) = cost(s,u) + cost(u,v)
pi[v] = u

*** Pattern matching
Rabin-Karp algorithm for pattern matching

See [[#hash_tables]] for H(S)
Compare hashes for P and S[i]->S[i+|P|]
Computing hashes of succesive substrings of S can be done as following
H(S,j+1) = x*(H(S,j) -x^(|P|-1) * S[j]) + S[j+|P|]

** Set Algorithms
*** Determine disjoint sets
M, N
Sort(min(M,N))
Run Binary search on smaller set using elements of bigger set
complexity (n+m)logm

*** Union Find
#+BEGIN_SRC java
//Complexity MN where M is number of unions
  int[] ids = new int[N]; //Initialize
  for (int i = 0; i<N; i++)
      ids[i] = i;
  boolean isConnected(int p, int q) {
      int t = ids[p];
      if (ids[q] == t)
          return true;
      else {
          for (int i=0; i<N; i++) {
              if (ids[i] == t)
                  ids[i] = ids[q];
          }
      }
      return false;
  }

#+END_SRC

*** Quick union find
Add objects to trees structure and to determine if two are connected check if their parent's root is same
#+BEGIN_SRC java
  int ids = new int[N];
  for(int i = 0;i<N;i++) ids[i] = i;

  boolean isConnected(int p, int q) {
      for (int i = ids[p]; i != ids[i]; i = ids[i]);
      for (int j = ids[q]; i != ids[j]; i = ids[j]);

      if (i == j)
          return true;
      else
          ids[j] = i;
      return false;
  }

#+END_SRC

*** Weighted quick unions
Maintain size of trees and only append the smaller tree to the larger tree

Worst case isConnected(): 2lgN
Worst case find: lgK where k is number of objects
#+BEGIN_SRC java
  int ids = new int[N];
  int sz = new int[N];

  for(int i = 0;i<N;i++) ids[i] = i;
  for(int i = 0;i<N;i++) sz[i] = 1;

  boolean isConnected(int p, int q) {
      for (int i=p; i != ids[i]; i = ids[i]);
      for (int j=q; j != ids[j]; j = ids[j]);

      if (i == j)
          return true;
      else {
          if (sz[i] < sz[j]) {
              ids[i] = j; sz[j] += sz[i];
          } else {
              ids[j] = i; sz[i] += sz[j];
          }
      }
      return false;
  }

#+END_SRC

*** Weighted quick union with path compression by halving
Reduce number of link in each tree by linking a node it's grandparent rather than parent.
#+BEGIN_SRC java
    int ids = new int[N];
    int sz = new int[N];

    for(int i = 0;i<N;i++) ids[i] = i;
    for(int i = 0;i<N;i++) sz[i] = 1;

    boolean isConnected(int p, int q) {
        for (int i=p; i != ids[i]; i = ids[i])
            ids[i] = ids[ids[i]]
        for (int j=q; j != ids[j]; j = ids[j])
            ids[j] = ids[ids[j]]

        if (i == j)
            return true;
        else {
            if (sz[i] < sz[j]) {
                ids[i] = j; sz[j] += sz[i];
            } else {
                ids[j] = i; sz[i] += sz[j];
            }
        }
        return false;
    }

#+END_SRC

** Graph algorithms
[[#graph_attributes]]

- BFS -> Queue to store unprocessed,discovered vertices, DFS -> Stack
*** Finding connected nodes on a graph
-Undirected Graph
Foreach edge (vertex a b)
union(a,b)


*** Breadth First Search

Linear complexity O(m+n) provided using adjacency list
#+BEGIN_SRC python
parent[], status[] {undiscovered->discovered->processed}, Q

for v in S - {root}:
  state[v] = undiscovered
  p[v] = nil

state[root] = discovered
p[root] = nil
Q = {root}

while Q not empty
  u = dequeue(Q)

  foreach v in adj(u)
   process_early(v)
   process_edge(u, v)
   if state[v] = undiscovered
     state[v] = discovered
     p[v] = u
     enqueue(Q, v)

  state[u] = processed
#+END_SRC

**** Finding connected components
#+BEGIN_SRC python
def connected_components(g):
 initialize_search(g)
 c = 0
 for v in g->V
  if(discovered[v] == false):
   c++
   bfs(g, v)

def process_vertex_early(c, v):
  component[c][] = v
#+END_SRC


**** Two coloring graph
coloring vertices so that each edge (x, y) has two opposite colored vertices.
#+BEGIN_SRC python
def twocolor(g):
 for v in g->V
  color[v] = uncolored

 for v in g->V
  if(discovered[v] == false):
   color[v] = white
   bfs(g, v)

def process_edge(x, y):
 if(color[x] == color[y]):
  print "graph cannot be two colored"
  exit
 else:
  color[y] = complement(color[x])
#+END_SRC


*** Shortest path
**** After BFS
#+BEGIN_SRC python
def shortest_path(start, end, parent):
static path
  if(start == end || end == nil):
    path[] = end
  else:
    shortest_path(start, parent[end], parent)
    path[] = end
#+END_SRC
**** Dijkstra's algorithm
***** pseudo
#+BEGIN_SRC python
#+END_SRC
***** Implementation
#+BEGIN_SRC python
def prim(graph g, start):
  inTree = []
  distance = []
  parent = []

  for v in g
    distance[v] = max
    parent[v] = -1
    inTree[v] = false

  v = start
  distance[v] = 0
  while inTree[v] == false
    inTree[v] = true
    for w in adj[v]
      if distance[w] > distance[v] + w->weight
        distance[w] = distance[v] + w->weight
        parent[w] = v

    v = 1
    dist = max
    for u in g
      if inTree[u] == false && dist > distance[u]
        v = u
        dist = distance[u]
#+END_SRC



**** Floyd Warshall algorithm
- Used for finding shortest path between all pairs of vertices
- O(n^3) same as Dijkstra but heuristically better
- Uses Adjacency Matrix
***** Implementation
def floyd (matrix g):
for k in g
  for j in g
    for j in g
      through_k = g->weight[i][j] + g->weight[k][j]
      if through_k < g->weight[i][j]
        g->weight[i][j] = through_k


*** Depth First Search
- Used to find connected component of graph? [[#graph_attributes]]

- Is used to determine backedges(descendent->ancestor) and tree edges(descendant->parent)

- Needs to check for cycles in process_edge and terminate if found
**** Algorithm
#+BEGIN_SRC python
entry[], exit[] //not part of actual dfs, keep track of entry,exit times for each vertex
time = 0

def DFS(G, u):
  status[u] = discovered
  entry[u] = time
  time++
  process_vertex_early(u)
    for v in Adj(u):
      process_edge(u,v)
      if(status[v] == undiscovered):
        status[v] = discovered
        parent[v] = u
        DFS(G, v)
   process_vertex_late(u)
   status[u] = processed
   exit[u] = time
   time++

def ancestor?(anc, desc):
  return entry[anc] < entry[desc] && exit[anc] > exit [desc]

def num_descendants(u):
  return (exit[u] - entry[u]) / 2


#+END_SRC
**** Finding cycles
#BEGIN_SRC python
def process_edge(u,v):
  if (parent[v] !=  u):
    print shortest_path(v, u)
#+END_SRC

**** Tracking ancestors
#+BEGIN_SRC python
def process_vertex_early(u):
  reachable_ancestor[u] = u //Initialization

def edge_classification(x, y):
  if(parent[y] == x): return TREE
  if (status[y] == discovered && status[y] != processed): return BACK
  if (status[y] == processed && entry[y] > entry[x]): return FORWARD //only for directed?
  if (status[y] == processed && entry[y] < entry [x]): return CROSS //only for directed?


def process_edge(u, v):
  if(edge_classification(u, v) == TREE) // see [[#graph_attributes]]
    tree_out_degree[u]++
  else if (edge_classification(u, v) == BACK && parent[u] != v):
    if (entry[v] < entry[reachable_ancestor[u]]):
      reachable_ancestor[u] = v
#+END_SRC

**** Tracing articulation vertices

def process_vertex_late(v):
  time_v = 0
  time_parent = 0

  if(parent[v] < 1 && tree_out_degree[v] > 1):
    print "Root articulation vertex " . v

  root = (parent[parent[v]] < 1):

  if(reachable_ancestor[v] == parent[v] && !root):
    print "parent articulation vertex" . parent[v]

  if(reachable_ancestor[v] == v):
    print "Bridge Articulation vertex " . parent[v]
    if(tree_out_degree[v] > 0)
      print "Bridge Articulation vertex " . v

  time_v = entry_time[reachable_ancestor[v]]
  time_parent = entry_time[reachable_ancestor[parent[v]]]

  if(time_v < time_parent):
    reachable_anestor[parent[v]] = reachable_ancestor[v]



**** Topological sorting
Reverse(Order in which vertices are marked processed)
Can be performed only on directed acyclic graphs (no back edges)

#+BEGIN_SRC python
def process_vertex_late(v):
  push(stack, v)

def process_edge(u, v):
  class = edge_classification(u, v)
  if(class == BACK):
    print "Back edge found"

def topsort(g):
  init_stack(stack)
  for(v in V):
    if(status[v] == undiscovered):
      dfs(g, v)
  print_stack(stack)
#+END_SRC

**** Finding connected components
G is connected if arbitary vertex v is reachable from all vertices and all vertices are reachable from v in G' where G' is G reversed(all edges reversed)


*** Minimum spanning tree

**** Prim's algorithm

#+BEGIN_SRC python
v = any vertex
T = empty graph
add v to T
while !empty(Non-tree vertices)
  select edge with minimum weight between tree and non-tree vertex
  add vertex and edge to T
#+END_SRC

#+BEGIN_SRC python
def prim(graph g, start):
  inTree = []
  distance = []
  parent = []

  for v in g
    distance[v] = max
    parent[v] = -1
    inTree[v] = false

  v = start
  distance[v] = 0
  while inTree[v] == false
    inTree[v] = true
    for w in adj[v]
      if inTree[w] == false && distance[w] > w->weight
        distance[w] = w->weight
        parent[w] = v

    v = 1
    dist = max
    for u in g
      if inTree[u] == false && dist > distance[u]
        v = u
        dist = distance[u]
#+END_SRC

complexity O(n^2)


**** Kruskal's algorithm

complexity O(mlogm) {m edges} if done with union-find datastructure

***** Basic algorithm
Put all m edges in min-heap
count = 0
while count < n-1
  get edge(v,w) from queue
  if(component(v) != component(w))
    add edge to Tmin
    Merge component(v) and component(w)




***** Union-find data structure
Represents a component as a backwards tree - To find the component of a vertex follow parent nodes until you get to root

def struct set_union:
  int p[MAX_SIZE+1]	//parent array
  int size[MAX_SIZE+1]	// size of subtree i
  int n			//number of elements in set

****** find(i) // Find component
def find(set_union s, int x):
  if(s->p[x] == x):
    return x
  else:
    return find(s->p[x], x)



****** union_sets(set_union s, int s1, int s2)
r1 = find(s1)
r2 = find(r2)
if(s->size[r1] >= s->size[r2]):
  s->size[r1] = s->size[r1] + s->size[r2]    // Merge smaller subtree into larger because it minimizes the increase in height of overall tree
  s->p[r2] = r1
else:
  s->size[r2] = s->size[r1] + s->size[r2]
  s->p[r1] = r2


*** Network Flow
Represented by a graph with a source node s connected to L portion of the bipartite graph which is connected to R portion connected to sink node t
  a- p
 /    \
s-b- q-t
 \    /
  c- r
A network is optimal iff there is no augmenting path
i.e. Presence of a path in the residual graph from s to t (Extra flow that can be pushed out represented by minimum edge weight on this path)

Edmonds and Karp algorithm O(n^3)
**** Implementation
***** Edge node def
struct {
int v
int capacity
int flow
int residual
edgenode next
}

***** func netflow // Constructs optimal network
#+BEGIN_SRC python
def netflow(flow_graph g, source, sink):
  add_residual_edges(g)

  initialize_search(g)
  bfs(g, source)
  volume = path_flow(g, source, sink, parent)

  while (volume > 0) {
    augment_path(g, source, sink, parent, volume)
    initialize_search(g)
    bfs(g, source)
    volume = path_flow(g, source, sink, parent)
  }

// bfs only considers edges with e->residual > 0
// Initializing consists of creating edges (i,j) and (j,i) for each edge in network and setting flows to 0, and residual flows to capacity for (i,j) and 0 for (j,i)
#+END_SRC
***** func path_flow // Returns minimum residual flow in path from source to sink i.e. constraining edge
#+BEGIN_SRC python
func path_flow(flow_graph g, start, end, parent)

  e = find_edge(parent[end], end) //Simply retrieves the edge node from the adjacency list
  if (start == parent[end])
    return e->residual
  else
    return min(path_volume(g, start, parent[end], parent), e->residual)
#+END_SRC

***** func augment_path // Updates flow and residual flow of edge(i,j) and (j,i) for path between source and sink
#+BEGIN_SRC python
func augment_path(g, start, end, parent, volume)

  if(start == end) return

  e = find_edge(parent[end] ,end)
  e->flow += volume
  e->residual -= volume

  e = find_edge(g, end, parent[end])
  e->residual += volume

  augment_path(g, start, parent[end], parent, volume)

#+END_SRC

** Combinatorial algorithms
*** Backtracking
**** PSEUDO
#+BEGIN_SRC python
def Backtrack-DFS(A, k):
 if(isSolution(A)): return A
 else:
  k++
  S = S(k) //Set of possible changes
  while S not empty
   S = S - A(k)  //A(k) = next possible change
   Backtrack-DFS(A, k)
#+END_SRC


**** Implementation
#+BEGIN_SRC python
def backtrack(int a[], int k, input):  //input: Extra data e.g. size of permutation
 int c[] //Candidates
 int ncandidates

 if(is_solution(a,k,input)): process_solution(a)
 else:
  k++
  construct_solutions(a,k,c,ncandidates) //Customized to problem
  for i ; i<ncandidates ; i++
   a[k] = c[i]
   make_move(a,k,input)                  //Custmoized to problem
   backtrack(a,k,input)
#+END_SRC


**** Generating subsets of {1,..,n} 2^n subsets in total
Subset S modeled by array a[] where a[i] = true => ith element in S
#+begin_src python
def is_solution(int a[], int k, int n):
 return k==n

def construct_candidates(int a[], int k, int n, int c, int ncandidates):
 c[0] = true
 c[1] = false
 &ncandidates = 2

def process_solution(int a[], int k):
 print "{"
 for i 1->k
  if(a[i]) print i
 print "}"
#+end_src


**** Generating n! permutations of {1,..,n}

Same as generating subsets except construct_candidates, candidate for ith position in a permutation is all elements not in previous i-1 positions
#+begin_src python
def construct_candidates(int a[], int k, int c, int ncandidates):
 bool inPerm[] //initialize to false
 for i 0->k:
  inPerm[a[i]] = true

 for i 1->k:
  if (!inPerm[i]):
   c[ncandidates] = i
   ncandidates++
#+end_src




* Complexity
** O(g) Omega(g) and Phi(g)
O(g) is the growth rate for a set of functions f which grow slower than g such that
       f(n)
lim    ---  <= c    or f(n) <= cg(n) for n > N
n->inf g(n)

means g is an upper bound for growth rate for f

Omega(g) is the growth rate for a set of functions f which grow faster than g such that
f(n) >= cg(n) means g is lower bound for f

Phi(g) = Omega(g) intersection O(g)

so f(n)/g(n) = c , both grow at same rate



** Mathematics
- Growth rate of sum of terms is growth rate of fastest term, and coefficients are not significant
i.e. O(an^3 + bn^2) => O(n^3)

- Growth rate of a polynomial is determined by its degree
O(n^d) where d is degree

- Growth rate for product of functions is given by the product of their upper bounds O(g)
i.e. g is O(n^2) h is O(logn) then gh is O(n^2logn)

- Exponential functions grow faster than powers?
O(n^2) > O(2^n) ? n^4 = O(2^n)

- Logarithms grow at same rate regardless of base
logb(n) = Phi(logd(n))

- Growth rate of a summation function grows is the power of summed variable + 1
e.g. Sigma (i^k) is Phi(n^(k+1))

Polynomial Time means growth rate is O(n^d)


** Measuring complexity
Function with a single op is O(1) so number of statements within a loop body are not significant as they are a coefficient for growth rate
so a f(n) for(i n) {s} is O(n)
and for(i n) {for(j n) s} is O(n^2)

Loop in which iteration var is a multiple of a constant, means growth rate is O(logb(n))
e.g. while(i < n) {i *= 2; s;} is O(log2(n))

Growth rate of function with nested loops can be decomposed into two functions?
with the growth rate being the product of their WORST CASE growth rates
e.g. Pattern matching
string p, s
n=strlen(p), m=strlen(s)

 for(i=0;i<(n-m);i++)
  j=0
  while (j<m && p[j] == s[i+j])
   j++
  if(j==m) return i
return -1

complexity (n-m)m = nm - m^2 = O(nm)


(while [h > 0] (for [i n] s) h = h/2)
growth rate is O(log2(n)) for outer * O(n) for inner = O(nlog2(n))

*** Using Recurrence Relation // for divide and conquer algorithms
T(n) => Worst case complexity

T(n) = a * T(n/b) + f(n)    n/b = size of subproblem, a = number of subproblems, f(n) = cost to combine sub solutions into one

Or in terms of recursion tree n/(b^k) = Partition size at level k,  a = vertex degree at each node, n^(logb (a)) = cost of leaves combined

Cases:
- If f(n) = O(n^(logb (a) - E)) for const E > 0
  then T(n) = Phi(n^(logb (a)))           //When cost of leaves dominates in a recursion tree

- If f(n) = Phi(n^(logb (a)))
  then T(n) = Phi(n^(logb (a)) * ln(n) )  //When cost/level in the tree is same ln(n) height of tree * logb(a) cost/level

- If f(n) = Omega(n^(logb (a) + E)) for const E > 0 and a * f(n/b) <= c * f(n) for some c < 1
  then T(n) = Phi(f(n))                  //When Root cost dominates


* Concurrency
** Libraries and Classes
java.util.concurrent

AtomicInteger, AtomicLong etc since operations on standard vars are not immediately visible

*** java.util.concurrent.Executor
.newFixedThreadPool(n) creates a pool of threads which read from queue of runnables
.newSingleThreadExecutor in case just a single thread is needed
**** Adding tasks to queue
.execute(Runnable t)
.submit(Callable c)  Returns a Future


** Keywords
*** synchronize
-Force atomic execution of a block of code in a multithread environment.
-Can be used to as a identifier for a block of code or as a function defn modifier.

*** volatile
Modifier for variable declaration. Makes any change made visible immediately

*** final
-Modifier make a variable or class immutable


** Threads
Initialized with a Runnable type e.g. new Thread(^:Runnable task)
Or a Callable type, returns a result

** Callables
Returns a java.util.concurrent.Future on which .get() can be called to check current value

** Addendum
CAS (Compare and Swap) Used in non-blocking algoritms


* Math
any exponent a^b can be decomposed into e^(ln(a^b)) = e^(b*ln(a)) since ln(x^y) = y*ln(x)

fun pow(x,y)
if (y==0) return 1
a = pow(a, y/2)
if(even(y)) return a^2
else return x*a^2

n
Sigma 1/i approx ln(n)
i=1

loga(b) => logc(b)/logc(a)


* Theory
** Parsing


* Sound Synthesis

** Sine waves
Sine wave fundamental building block of sound
Function form
f = 1/T
p(t) = Asin(2*pi*t)/T = Asin(2*pi*f*t)

*** Algorithm to generate sinusoidal wave
Input: Peak amplitude (A), Frequency (f)
Output: Amplitude value (y)

y = A * sin(phase)

phase = phase + ((2 * pi * f) / samplerate)

if phase > (2 * pi) then
      phase = phase - (2 * pi)


** Frequencies
 > 1.5 KHz Treble
 > 200 Hz Bass

Note  Freq
C4    261.63
C#4   277.18
D4    293.66
D#4   311.13
E4    329.63
F4    349.23
F#4   369.99
G4    392.00
G#4   415.30
A4    440.00
A#4   466.16
B4    493.88
C5    523.25

fk = (2^(1/12))^k * 261.63,


Wavelength (t)	Frequency (Hz)	Note name
156.82 cm	220.0	        A3
139.71 cm	246.94	        B3
131.87 cm	261.63	        C4
117.48 cm	293.66	        D4
104.66 cm	329.63	        E4
98.79 cm	349.23	        F4
88.01 cm	392.0	        G4
78.41 cm	440.0	        A4


*** Division into cents
Since there are 12 tones, and the frequency doubles in an octave interval,
the semitone intervals in an equal tempered scale are each related by the 12th root of two, which is approximately 1.059,463.
Semitones are split up into 100 cents, but most human beings can only detect changes in pitch of 5 cents or more.
Cent intervals are related by the 1200th root of 2, which is approximately 1.00,057,779.
As an example of what this represents in terms of frequency: for a A5 note of 880Hz, a cent is just below 0.51 Hz, and thus 5 cents represent only 2.5 Hz!



** Sampling
Digital representation requires collecting data points of the waveform.
Standard sampling rate is 44.1 Khz which is twice the average audible frequency of 20 Khz

Bit Depth - precision with which the amplitude of a sample point is recorded e.g. Comapct Disc have 16 binary bits

Steps (Data Points?) per cycle
S = T * Fs  where T is Time period and Fs is sampling rate

*** Nyquist Frequency
The sampling rate must be atleast twice the maximum frequency of the waveform
F = S/2 where F is Nyquist frequency
Analogue to digital converters filter out frequencies higher than F since they cannot be sampled well.


** Square wave

*** Algorithm
Input: Peak amplitude (A), Frequency (f)
Output: Amplitude value (y)

if phase < pi then
      y = A
else
      y = -A

phase = phase + ((2 * pi * f) / samplerate)

if phase > (2 * pi) then
      phase = phase - (2 * pi)


** Sawtooth wave

*** Algorithm
Input: Peak amplitude (A), Frequency (f)
Output: Amplitude value (y)

y = A - (A / pi * phase)

phase = phase + ((2 * pi * f) / samplerate)

if phase > (2 * pi) then
      phase = phase - (2 * pi)


** Beats
Slight differences of frequency between two waveforms can produce a differ- ent effect.
Assuming that the two waveforms start at the same zero crossing, and with the same phase,
then the waveform with the higher frequency will gradually move ahead of the slower waveform, and its phase will be ahead.
This means that from an initial state of constructive interference, the wave- forms will pass through destructive interference and then back to constructive interference repeatedly.
The rate of passing through these adding and cancella- tion stages is determined by the difference in frequency.
For a difference of one- tenth of a hertz, it will take 10 seconds for the cycle of constructive, destructive and constructive interference to occur.
This cyclic variation in level of the mixed waveforms is called â€˜beatingâ€™, and sounds like a sound that â€˜wobblesâ€™ in level.
This beating is often used in analogue synthesizers to provide a â€˜livelyâ€™ or â€˜interestingâ€™ sound.
If the difference in frequency between the two waveforms is increased, then the speed of the beats will increase.
When the frequency of the beats is above 20Hz, then the mixed sound begins to sound like two separate frequencies.
As the difference increases, the two frequencies will pass through a series of ratios of frequency, some of them sounding pleasant to the ear, and others sound- ing unpleasant.
The ratio between the two frequencies is called an interval; the easiest and most â€˜pleasingâ€™ interval is a ratio of 2:1, an octave.



** SuperCollider
*** Patterns
based on Events e.g. note event
**** Pbind
Pbind(type: \note, instrument: \sine(synthdef)) returns stream event player which generates note events

**** Pseq
Duplicates sequence
e.g. Pseq([0.6, 0.15], inf) generates infinte series of input sequence
can be fed to Pbind e.g.
Pbind(type: \note, instrument: \sine(synthdef), dur: Pseq([0.6, 0.15], inf), freq: Pseq([330, 247], inf))


* Algorithms in Java
Connectivity Problem


* Java
** OOP
*** Inner Classes
Nested classes can access private members of outer classes and vice versa.
You can pass only final variables to a local inner class.

#+BEGIN_SRC java
  //Static Inner class
/**
- When you define an inner nested class (or interface) inside an interface, the nested class is declared implicitly public and static.
- Any field in an interface is implicitly declared public and static, and static nested classes have this same behavior.
- Static nested classes can be declared abstract or final.
- Static nested classes can extend another class or it can be used as a base class.
- Static nested classes can have static members. (this statement does not apply to other kinds of nested classes.)
- Static nested classes can access the members of the outer class (only static members, obviously).
- The outer class can also access the members (even private members) of the nested class through an object of nested class. If you don't declare an instance of the nested class,
the outer class cannot access nested class elements directly. */

  class Outer{
      static class StaticNested{ //class definition
      }
  }

  // Non-local Inner class
/**
- Every inner class is associated with an instance of the outer class. in other words, an inner class is always associated with an enclosing object.
- An inner class object can only be constructed by this.new InnerClass();
- An inner class can't have static members
*/
  class Outer{
      class Inner {
      //class definition
      }
  }

  // Local Inner Class
/**
- You can create a non-static local class inside a body of code. Interfaces cannot have local classes, and you cannot create local interfaces.
- Local classes are accessible only from the body of the code in which the class is defined. The local classes are completely inaccessible outside the body of the code in which the class is defined.
- You can extend a class or implement interfaces while defining a local class.
- A local class can access all the variables available in the body of the code in which it is defined.
You can pass only final variables to a local inner class.*/
  class Outer{
      void foo() {
          class LocalInner{
          }
      }
  }

  // Local Anonymous class
//Can't have static members
  class Outer{
      void foo() {
          return new Object(){
              public String toString(){
                  return "anonymous";
              }
          }
              }
  }
#+END_SRC

**** Enumerated type
a constructor in an enum class can only be specified as private.
#+BEGIN_SRC java
  public enum PrinterType {
      DOTMATRIX(5), INKJET(10), LASER(50);
      private int pagePrintCapacity;
      private PrinterType(int pagePrintCapacity) {
          this.pagePrintCapacity = pagePrintCapacity;
      }
      public int getPrintPageCapacity() {
          return pagePrintCapacity;
      }

  }
  // EnumTest.java
  public class EnumTest {
      PrinterType printerType;
      public EnumTest(PrinterType pType) {
          printerType = pType;
      }
      public void feature() {
          switch (printerType) {

          case DOTMATRIX:
              System.out.println("Dot-matrix printers are economical");
              break;
          case INKJET:
              System.out.println("Inkjet printers provide decent quality prints");
              break;
          case LASER:
              System.out.println("Laser printers provide the best quality prints");
              break;
          }
          System.out.println("Print page capacity per minute: " +
                             printerType.getPrintPageCapacity());
          public static void main(String[] args) {
              EnumTest enumTest1 = new EnumTest(PrinterType.LASER);
              enumTest1.feature();
              EnumTest enumTest2 = new EnumTest(PrinterType.INKJET);
              enumTest2.feature();
          }
      }
  }
#+END_SRC




** Strings
indexOf(char/String) : return index, -1 on failure
indexOf(String, fromIndex) : return index, with search starting from fromIndex

valueOf() to convert a primitive into a string

*** Compare substrings
| Method                                                                                                    | Description                                                                                                                                                                   |
| boolean regionMatches(int start  String matchingStr int matchStartOffset int matchLen)                    | Starting from start in this String object check if the region of text given by matchingStr matches. In matchStr check for matchLen characters starting from matchStartOffset. |
| boolean regionMatches(boolean ignoreCase int start String matchingStr  int matchStartOffset int matchLen) | Same as the previous method but with the additional first argument which ignores the case differences.                                                                        |


*** Regular Expressions
String.split() uses regexes to split strings.

java.util.Pattern and java.util.Matcher are much optimized for regex operations.
\d Matches digits (equivalent to [0-9]).
\D Matches non-digits.
\w Matches word characters.
\W Matches non-word characters.
\s Matches whitespaces (equivalent to [\t\r\f\n]).
\S Matches non-whitespaces.
\b Matches word boundary when outside bracket. Matches backslash when inside bracket.
\B Matches non-word boundary.
\A Matches beginning of string.
\Z Matches end of string.

Index
| start(), start(int group) | returns index of expression or subsequence                     |
| end(), end(int group)     | returns offset for last character of expression or subsequence |

Study
| lookingAt()             | returns true if a subsequence of string matches                         |
| find(), find(int start) | returns boolean indicating if a next match was found for the expression |
| matches()               | attemps to match the entire string to the expression                    |

Replacement
| Matcher appendReplacement(StringBuffer, String replacement)             | non-terminal append and replace                           |
| StringBuffer appendTail(StringBuffer)                                   | terminal append and replace.                              |
| String replaceAll(String replacement), replaceFirst(String replacement) | Replaces all, first match respectively                    |
| String quoteReplacement(String s)                                       | Returns a replacement string for use by appendReplacement |

#+BEGIN_SRC java
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;

  public class Regex1 {
      public static void main(String[] args) {
          String str = "Danny Doo, Flat no 502, Big Apartment, Wide Road, Near Huge Milestone, Hugo-city 56010, Ph: 9876543210, Email: danny@myworld.com. Maggi Myer, Post bag no 52, Big bank post office, Big bank city 56000, ph: 9876501234, Email: maggi07@myuniverse.com.";
          Pattern pattern = Pattern.compile("\\w+");
          Matcher matcher = pattern.matcher(str);
          while(matcher.find()) {
              System.out.println(matcher.group());
          }
      }
  }


#+END_SRC

Replacing
#+BEGIN_SRC java
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;

  // This program demonstrates how we can manipulate text public
  class Regex6 {
      public static void main(String[] args) {
          String str = "Danny Doo, Flat no 502, Big Apartment, Wide Road, Near Huge Milestone, Hugo-city 56010, Ph: 9876543210, Email: danny@myworld.com. Maggi Myer, Post bag no 52, Big bank post office, Big bank city 56000, ph: 9876501234, Email: maggi07@myuniverse.com.";

          Pattern pattern = Pattern.compile("(\\D)(\\d{3})(\\d{7})(\\D)");
          Matcher matcher = pattern.matcher(str);
          String newStr = matcher.replaceAll("$1$2-$3$4");
          System.out.println(newStr);
      }
  }


#+END_SRC

**** Formatting using printf()
%[flags][width][.precision]datatype_specifier
flags: Used to specify alignment, padding character
width: minimum length of string produced
precision: optional field for floats/double

String.format(format, args) returns a string which can be printed

| Symbol | Description                                                                                       |
| %b     | Boolean                                                                                           |
| %c     | Character                                                                                         |
| %d     | Decimal integer (signed)                                                                          |
| %e     | Floating point number in scientific format                                                        |
| %f     | Floating point numer in decimal format                                                            |
| %g     | Floating point numer in decimal or scientific format (depending on the  value passed as argument) |
| %h     | Hashcode of the passed argument                                                                   |
| %n     | Line separator (new line character)                                                               |
| %o     | Integer formatted as an octal value                                                               |
| %s     | String                                                                                            |
| %t     | Date/time                                                                                         |
| %x     | Integer formatted as an hexadecimal value                                                         |



** IO
System.console()


| Method                                         | Short description                                                                                                                                                                                                                                                                                                                                    |   |
| Reader reader()                                | Returns the Reader object associated with this Console object; can perform read operations through this returned reference.                                                                                                                                                                                                                          |   |
| PrintWriter writer()                           | Returns the PrintWriter object associated with this Console object; can perform write operations through this returned reference.                                                                                                                                                                                                                    |   |
| String readLine()                              | Reads a line of text String (and this returned string object does not include any line termination characters); returns null if it fails (e.g. the user pressed Ctrl+Z or Ctrl+D in the console)                                                                                                                                                     |   |
| String readLine(String fmt Object... args)     | Same as the readLine() method but it first prints the string fmt.                                                                                                                                                                                                                                                                                    |   |
| char[] readPassword()                          | Reads a password text and returns as a char array; echoing is disabled with this method so nothing will be displayed in the console when the password is typed by the user.                                                                                                                                                                          |   |
| char[] readPassword(String fmt Object... args) | Same as the readPassword() method but it first prints the string given as the format string argument before reading the password string.                                                                                                                                                                                                             |   |
| Console format(String fmt Object... args)      | Writes the formatted string (created based on values of fmt string and the args passed) to the console.                                                                                                                                                                                                                                              |   |
| Console printf(String fmt Object... args)      | Writes the formatted string (created based on values of fmt string and the args passed) to the console. This printf method is the same as the format method: This is a “convenience method”—the method printf and the format specifiers are familiar to most C/C++ programmers so this method is provided in addition to the format method. |   |
| void flush()                                   | Flushes any of the data still remaining to be printed in the console object’s buffer                                                                                                                                                                                                                                                              |   |

System.console has better support for unicode than regular System.out
*** Streams
Character Streams java.io.Reader, java.io.Writer used for text io where medium are 16 bit unicode characters
Byte Streams java.io.InputStream java.io.OutputStream used for binary data, medium is...a byte character

**** Character Streams
***** Reader
                                Reader
        __________________________|______________________________________
       |               |                 |              |                |
BufferedReader    FilterReader     PipedReader   InputStreamReader  StringReader
       |               |
LineNumberReader  PushbackReader

| StringReader      | A character stream that operates on  strings.                                                                                                      |
| InputStreamReader | This class is a bridge between character streams and byte streams.                                                                                 |
| FileReader        | Derived class of InputStreamReader that provides support for reading character files.                                                              |
| PipedReader       | The PipedReader and PipedWriter classes form a pair for “piped” reading/writing  of characters.                                              |
| FilterReader      | Abstract base class for streams that support a filtering operation applied on data as characters are read from the stream.                         |
| PushbackReader    | Derived class of FilterReader that allows read characters to be pushed back into the stream.                                                       |
| BufferedReader    | Adds buffering to the underlying character stream so that there is no need to access the underlying file system for each read and write operation. |
| LineNumberReader  | Derived class of BufferedReader that keeps track of line numbers as the characters are read from the underlying character stream.                  |


***** Writer
                                Writer
        __________________________|_________________________________________________
       |               |                 |              |                |          |
BufferedWriter    PipedReader     OutputStreamWriter  StringWriter   PrintWriter  FilterWriter
                                         |
                                     FileWriter

| StringWriter       | A character stream that collects the output in a string buffer, which can be used for creating a string.                                           |
| OutputStreamWriter | This class is a bridge between character streams and byte streams.                                                                                 |
| FileWriter         | Derived class of OutputStreamWriter that provides support for writing character files.                                                             |
| PipedWriter        | The PipedReader and PipedWriter classes form a pair for “piped” reading/writing of characters in character stream.                           |
| FilterWriter       | Abstract base class for streams that supports a filtering operation applied on data as characters when writing them to a character stream.         |
| PrintWriter        | Supports formatted printing of characters to the output character stream.                                                                          |
| BufferedWriter     | Adds buffering to the underlying character stream so that there is no need to access the underlying file system for each read and write operation. |

***** Operations
Example of reading and writing
#+BEGIN_SRC java
  import java.io.BufferedReader;
  import java.io.BufferedWriter;
  import java.io.FileNotFoundException;
  import java.io.FileReader;
  import java.io.FileWriter;
  import java.io.IOException;

  // implements a simplified version of "copy" command provided in Windows // syntax: java Copy SrcFile DstFile // copies ScrFile to DstFile; over-writes the DstFile if it already exits class Copy {
  public static void main(String []files) {
      if(files.length != 2) {
          System.err.println("Incorrect syntax. Correct syntax: Copy SrcFile DstFile");
          System.exit(-1);
      }
      String srcFile = files[0];
      String dstFile = files[1];
      // try opening the source and destination file                // with FileReader and FileWriter
      try (BufferedReader inputFile = new BufferedReader(new FileReader(srcFile));
           BufferedWriter outputFile = new BufferedWriter(new FileWriter(dstFile))) {
              int ch = 0;
              // while there are characters to fetch, read the characters from                        // source stream and write them to the destination stream
              while( (ch = inputFile.read()) != -1) {
                  // ch is of type int - convert it back to char before                                // writing it
                  outputFile.write( (char)ch );
              }
              // no need to call flush explicitly for outputFile - the close()                        // method will first call flush before closing the outputFile stream                }
              catch (FileNotFoundException fnfe) {
                  // the passed file is not found ...
                  System.err.println("Cannot open the file " + fnfe.getMessage());
              }
              catch(IOException ioe) {
                  // some IO error occurred when reading the file ...
                  System.err.printf("Error when processing file;exiting ... ");
              }
              // try-with-resources will automatically release FileReader object        }
          }
  }


#+END_SRC

Example Tokenizing using java.util.Scanner
#+BEGIN_SRC java
  import java.io.FileNotFoundException;
  import java.io.FileReader;
  import java.util.Scanner;
  import java.util.Set;
  import java.util.TreeSet;

  // read the input file and convert it into "tokens" of words; // convert the words to same case (lower case), remove duplicates, and print the words

  class Tokenize {
      public static void main(String []args) {
          // read the input file
          if(args.length != 1) {
              System.err.println("pass the name of the file to be read as an argument");
              System.exit(-1);
          }
          String fileName = args[0];
          // use a TreeSet<String> which will automatically sort the words                // in alphabetical order
          Set<String> words = new TreeSet<>();
          try ( Scanner tokenizingScanner = new Scanner(new FileReader(fileName)) ) {
                  // set the delimiter for text as non-words (special characters,white-spaces, etc), meaning that all words other than punctuation characters, and white-spaces will be returned
                  tokenizingScanner.useDelimiter("\\W");
                  while(tokenizingScanner.hasNext()) {
                      String word = tokenizingScanner.next();
                      if(!word.equals("")) {
                          // process only non-empty strings                                        // convert to lowercase and then add to the set
                          words.add(word.toLowerCase());
                      }
                  }
                  // now words are in alphabetical order without duplicates,                        // print the words separating them with tabs
                  for(String word : words) {
                      System.out.print(word + '\t');
                  }
              }
          catch (FileNotFoundException fnfe) {
              System.err.println("Cannot read the input file - pass a valid file name");
          }
      }
  }


#+END_SRC


**** Byte Streams

                                     OutputStream
          ________________________________|____________________________________________________
         |                     |                    |                     |                    |
ByteArrayOutputStream   FileOutputStream    FilterOutputStream    ObjectOutputStream   PipedOutputStream
                                  ____________________|________________________
                                 |                    |                        |
                            PrintStream        DataOutputStream       BufferedOutputStream

DataOutput (Interface) -> ObjectOutput (Concrete ObjectOutputStream)
DataOutput implemented by subclasses of FilterOutputStream

| PipedInputStream, PipedOutputStream       | PipedInputStream and PipedOutputStream create a communication channel on which data can be sent and received. PipedOutputStream sends the data and PipedInputStream receives the data sent on the channel.             |
| FileInputStream, FileOutputStream         | FileInputStream receives a byte stream from a file, FileOutputStream writes a byte stream into a file.                                                                                                                 |
| FilterInputStream, FilterOutputStream     | These filtered streams are used to add functionalities to plain streams. The output of an InputStream can be filtered using FilterInputStream. The output of an OutputStream can be filtered using FilterOutputStream. |
| BufferedInputStream, BufferedOutputStream | BufferedInputStream adds buffering capabilities to an input stream. BufferedOutputStream adds buffering capabilities to an output stream.                                                                              |
| PushbackInputStream                       | A subclass of FilterInputStream, it adds “pushback” functionality to an input stream.                                                                                                                            |
| DataInputStream, DataOutputStream         | DataInputStream can be used to read java primitive data types from an input stream. DataOutputStream can be used to write Java primitive data types to an output stream.                                               |

Example Reading File header
#+BEGIN_SRC java
  import java.io.FileInputStream;
  import java.io.FileNotFoundException;
  import java.io.IOException;
  import java.util.Arrays;

  // check if the passed file is a valid .class file or not. // note that this is an elementary version of a checker that checks if the given file // is a valid file that is written according to the JVM specification // it checks only the magic number
  class ClassFileMagicNumberChecker {
      public static void main(String []args) {
          if(args.length != 1) {
              System.err.println("Pass a valid file name as argument");
              System.exit(-1);
          }

          String fileName = args[0];
          // create a magicNumber byte array with values for four bytes in 0xCAFEBABE                // you need to have an explicit down cast to byte since                // the hex values like 0xCA are of type int
          byte []magicNumber = {(byte) 0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE};
          try (FileInputStream fis = new FileInputStream(fileName)) {
                  // magic number is of 4 bytes –                        // use a temporary buffer to read first four bytes
                  byte[] u4buffer = new byte[4];
                  // read a buffer full (4 bytes here) of data from the file
                  if(fis.read(u4buffer) != -1) {
                      // if read was successful the overloaded method equals for two byte arrays // checks for equality of contents
                      if(Arrays.equals(magicNumber, u4buffer)) {
                          System.out.printf("The magic number for passed file %s matches that of a .class file", fileName);
                      }
                      else {
                          System.out.printf("The magic number for passed file %s does not match that of a .class file", fileName);
                      }
                  }
              }
          catch(FileNotFoundException fnfe) {
              System.err.println("file does not exist with the given file name ");
          }
          catch(IOException ioe) {
              System.err.println("an I/O error occurred while processing the file");
          }
      }
  }


#+END_SRC

Only one instance of a class can be serialized, all subsequent serialize calls are ignored (determined by serialVersionUID)
Example Serializing object
#+BEGIN_SRC java
  import java.io.FileInputStream;
  import java.io.FileNotFoundException;
  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.io.ObjectInputStream;
  import java.io.ObjectOutputStream;
  import java.util.HashMap;
  import java.util.Map;

  // A simple class to illustrate object streams: fill a data structure, write it to a // temporary file and read it back and print the read data structure
  class ObjectStreamExample {
      public static void main(String []args) {
          Map<String, String> presidentsOfUS = new HashMap<>();
          presidentsOfUS.put("Barack Obama", "2009 to --, Democratic Party, 56th term");
          presidentsOfUS.put("George W. Bush", "2001 to 2009, Republican Party, 54th and 55th terms");

          presidentsOfUS.put("Bill Clinton", "1993 to 2001, Democratic Party, 52nd  and 53rd terms");
          try (ObjectOutputStream oos = new ObjectOutputStream(new  FileOutputStream("object.data"))) {
                  oos.writeObject(presidentsOfUS);
              }
          catch(FileNotFoundException fnfe) {
              System.err.println("cannot create a file with the given file name ");
          }
          catch(IOException ioe) {
              System.err.println("an I/O error occurred while processing the file");
          }
          // the ObjectOutputStream will auto-close, so don't have to worry about it
          try (ObjectInputStream ois = new ObjectInputStream(new  FileInputStream("object.data"))) {
                  Object obj = ois.readObject();
                  // first check if obj is of type Map
                  if(obj != null && obj instanceof Map) {
                      Map<String, String> presidents = (Map<String, String>) obj;
                      System.out.println("President name \t Description \n");
                      for(Map.Entry<String, String> president : presidents.entrySet()) {
                          System.out.printf("%s \t %s %n", president.getKey(), president.getValue());
                      }
                  }
              }
          catch(FileNotFoundException fnfe) {
              System.err.println("cannot create a file with the given file name ");
          }
          catch(IOException ioe) {
              System.err.println("an I/O error occurred while processing the file");
          }
          catch(ClassNotFoundException cnfe) {
              System.err.println("cannot recognize the class of the object - is the file corrupted?");
          }
      }
  }


#+END_SRC


*** File system IO

**** Path interface
java.nio.path

| Path getRoot()                             | Returns a Path object representing the root of the given path, or null if the path does not have a root.                                                                                                                                                                                                                                                                                                                      |
| Path getFileName()                         | Returns the file name or directory name of the given path. Note that the file/directory name is the last element or name in the given path.                                                                                                                                                                                                                                                                                   |
| Path getParent()                           | Returns the Path object representing the parent of the given path, or null if no parent component exists for the path.                                                                                                                                                                                                                                                                                                        |
| int getNameCount()                         | Returns the number of file/directory names in the given path; returns 0 if the given path represents the root.                                                                                                                                                                                                                                                                                                                |
| Path getName(int index)                    | Returns the ith file/directory name; the index 0 starts from  closest name to the root.                                                                                                                                                                                                                                                                                                                                       |
| Path subpath(int beginIndex, int endIndex) | Returns a Path object that is part of this Path object; the returned Path object has a name that begins at beginIndex till the element at index endIndex - 1. In other words, beginIndex is inclusive of the name in that index and exclusive of the name in endIndex. This method may throw IllegalArgumentException if beginIndex is >= number of elements, or endIndex <= beginIndex, or endIndex is > number of elements. |
| Path normalize()                           | Removes redundant elements in path such as . (dot symbol that indicates current directory) and .. (double dot symbol that indicates parent directory). Path resolve(Path other)                                                                                                                                                                                                                                               |
| Path resolve(String other)                 | Resolves a path against the given path. For example, this method could combine the given path with the other path and return the resulting path.                                                                                                                                                                                                                                                                              |
| Boolean isAbsolute()                       | Returns true if the given path is an absolute path; returns false if not (when the given path is a relative path, for example).                                                                                                                                                                                                                                                                                               |
| Path startsWith(String path)               |                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Path startsWith(Path path)                 | Returns true if this Path object starts with the given path, or else returns false.                                                                                                                                                                                                                                                                                                                                           |
| Path toAbsolutePath()                      | Returns the absolute path.                                                                                                                                                                                                                                                                                                                                                                                                    |

#+BEGIN_SRC java
  import java.nio.file.*;
  // Class to illustrate how to use Path interface and its methods
  public class PathInfo1 {
      public static void main(String[] args) {
          // create a Path object by calling static method get() in Paths class
          Path testFilePath = Paths.get("D:\\test\\testfile.txt");
          // retrieve basic information about path
          System.out.println("Printing file information: ");
          System.out.println("\t file name: " + testFilePath.getFileName());
          System.out.println("\t root of the path: " + testFilePath.getRoot());
          System.out.println("\t parent of the target: " + testFilePath.getParent());
          // print path elements
          System.out.println("Printing elements of the path: ");
          for(Path element : testFilePath) {
              System.out.println("\t path element: " + element);
          }
      }
  }


#+END_SRC


**** java.nio.file.Files
Utility library for file manipulation

| Path createDirectory(Path dirPath, FileAttribute<?>. . . dirAttrs),Path createDirectories(Path dir, FileAttribute<?>. . . attrs)                   | Creates a file given by the dirPath, and sets the attributes given by dirAttributes. May throw exceptions such as FileAlreadyExistsException or UnsupportedOperationException (e.g., when the file attributes cannot be set as given by dirAttrs). The difference between createDirectory and createDirectories is that createDirectories creates intermediate directories given by dirPath if they are not already present. |
| Path createTempFile(Path dir, String prefix,  String suffix, FileAttribute<?>. . . attrs)                                                          | Creates a temporary file with given prefix, suffix, and attributes in the directory given by dir.                                                                                                                                                                                                                                                                                                                            |
| Path createTempDirectory(Path dir,  String prefix, FileAttribute<?>. . . attrs)                                                                    | Creates a temporary directory with the given prefix, directory attributes in the path specified by dir.                                                                                                                                                                                                                                                                                                                      |
| Path copy(Path source, Path target,  CopyOption. . . options)                                                                                      | Copy the file from source to target. CopyOption could be REPLACE_EXISTING, COPY_ATTRIBUTES, or NOFOLLOW_LINKS. Can throw exceptions such as FileAlreadyExistsException.                                                                                                                                                                                                                                                      |
| Path move(Path source, Path target,  CopyOption. . . options)                                                                                      | Similar to the copy operation except that the source file is removed; if the source and target are in the same directory, it is a file rename operation.  boolean exists(Path path,  LinkOption. . . options) Checks if a file/directory exists in the given path; can specify LinkOption.NOFOLLOW_LINKS to not to follow symbolic links.                                                                                    |
| boolean isSameFile(Path path, Path path2)                                                                                                          | Checks if the two Path objects locate the same  file or not.                                                                                                                                                                                                                                                                                                                                                                 |
| Boolean isRegularFile(Path path,  LinkOption. . .)                                                                                                 | Returns true if the file represented by path is a  regular file.                                                                                                                                                                                                                                                                                                                                                             |
| Boolean isSymbolicLink(Path path)                                                                                                                  | Returns true if the file presented by path is a  symbolic link.                                                                                                                                                                                                                                                                                                                                                              |
| Boolean isHidden(Path path)                                                                                                                        | Return true if the file represented by path is a  hidden file.                                                                                                                                                                                                                                                                                                                                                               |
| long size(Path path)                                                                                                                               | Returns the size of the file in bytes represented by path.                                                                                                                                                                                                                                                                                                                                                                   |
| UserPrincipal getOwner(Path path, LinkOption. . .), Path setOwner(Path path, UserPrincipal owner)                                                  | Gets/sets the owner of the file.                                                                                                                                                                                                                                                                                                                                                                                             |
| FileTime getLastModifiedTime(Path path,  LinkOption. . .), Path setLastModifiedTime(Path path, FileTime time)                                      | Gets/sets the last modified time for the specified time.                                                                                                                                                                                                                                                                                                                                                                     |
| Object getAttribute(Path path, String attribute,  LinkOption. . .), Path setAttribute(Path path,  String attribute, Object value, LinkOption. . .) | Gets/sets the specified attribute of the specified file.                                                                                                                                                                                                                                                                                                                                                                     |


Read multiple attributes
Map<String,Object> readAttributes(Path path, String attributes, LinkOption. . . options)

<A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption. . . options)

                 BasicFileAttributes
        _________________|________________
       |                                  |
DosFileAttributes                PosixFileAttributes

Attributes, setting file owner,group
#+BEGIN_SRC java
  import java.io.IOException;
  import java.nio.file.*;

  class FileAttributes {
      public static void main(String[] args) {
          Path path = Paths.get(args[0]);
          try {
              Object object = Files.getAttribute(path, "creationTime",  LinkOption.NOFOLLOW_LINKS);
              System.out.println("Creation time: " + object);
              object = Files.getAttribute(path, "lastModifiedTime",  LinkOption.NOFOLLOW_LINKS);
              System.out.println("Last modified time: " + object);
              object = Files.getAttribute(path, "size", LinkOption.NOFOLLOW_LINKS);
              System.out.println("Size: " + object);
              object = Files.getAttribute(path, "dos:hidden", LinkOption.NOFOLLOW_LINKS);
              System.out.println("isHidden: " + object);

              object = Files.getAttribute(path, "isDirectory", LinkOption.NOFOLLOW_LINKS);
              System.out.println("isDirectory: " + object);
          }
          catch (IOException e) {
              e.printStackTrace();
          }
      }
  }

  import java.io.IOException;
  import java.nio.file.*;
  import java.nio.file.attribute.*;

  class FileAttributes2 {
      public static void main(String[] args) {
          Path path = Paths.get(args[0]);
          try {
              BasicFileAttributes fileAttributes = Files.readAttributes(path, BasicFileAttributes.class);
              System.out.println("File size: " + fileAttributes.size());
              System.out.println("isDirectory: " + fileAttributes.isDirectory());
              System.out.println("isRegularFile: " + fileAttributes.isRegularFile());
              System.out.println("isSymbolicLink: " + fileAttributes.isSymbolicLink());
              System.out.println("File last accessed time: " +  fileAttributes.lastAccessTime());
              System.out.println("File last modified time: " +  fileAttributes.lastModifiedTime());
              System.out.println("File creation time: " + fileAttributes.creationTime());
          }
          catch (IOException e) {
              e.printStackTrace();
          }
      }

UserPrincipal owner = file.GetFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByName("sally");
Files.setOwner(file, owner);

GroupPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByGroupName("green");
Files.getFileAttributeView(file, PosixFileAttributeView.class)
     .setGroup(group);


//Mime-type
UserDefinedFileAttributeView view = Files
    .getFileAttributeView(file, UserDefinedFileAttributeView.class);
view.write("user.mimetype",
           Charset.defaultCharset().encode("text/html");

serDefinedFileAttributeView view = Files.getFileAttributeView(file,UserDefinedFileAttributeView.class);
String name = "user.mimetype";
ByteBuffer buf = ByteBuffer.allocate(view.size(name));
view.read(name, buf);
buf.flip();
String value = Charset.defaultCharset().decode(buf).toString();
#+END_SRC

Disk Usage
#+BEGIN_SRC java
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;

/**
 * Example utility that works like the df(1M) program to print out disk space
 * information
 */

public class DiskUsage {

    static final long K = 1024;

    static void printFileStore(FileStore store) throws IOException {
        long total = store.getTotalSpace() / K;
        long used = (store.getTotalSpace() - store.getUnallocatedSpace()) / K;
        long avail = store.getUsableSpace() / K;

        String s = store.toString();
        if (s.length() > 20) {
            System.out.println(s);
            s = "";
        }
        System.out.format("%-20s %12d %12d %12d\n", s, total, used, avail);
    }

    public static void main(String[] args) throws IOException {
        System.out.format("%-20s %12s %12s %12s\n", "Filesystem", "kbytes", "used", "avail");
        if (args.length == 0) {
            FileSystem fs = FileSystems.getDefault();
            for (FileStore store: fs.getFileStores()) {
                printFileStore(store);
            }
        } else {
            for (String file: args) {
                FileStore store = Files.getFileStore(Paths.get(file));
                printFileStore(store);
            }
        }
    }
}
#+END_SRC

POSIX File permissions
#+BEGIN_SRC java
PosixFileAttributes attr =
    Files.readAttributes(file, PosixFileAttributes.class);
System.out.format("%s %s %s%n",
    attr.owner().getName(),
    attr.group().getName(),
    PosixFilePermissions.toString(attr.permissions()));

PosixFileAttributes attrs =
    Files.readAttributes(sourceFile, PosixFileAttributes.class);
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(attrs.permissions());
Files.createFile(file, attr);

Set<PosixFilePermission> perms =
    PosixFilePermissions.fromString("rw-------");
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(perms);
Files.setPosixFilePermissions(file, perms);


#+END_SRC

***** ByteChannels
SeekableByteChannel
position â€“ Returns the channel's current position
position(long) â€“ Sets the channel's position
read(ByteBuffer) â€“ Reads bytes into the buffer from the channel
write(ByteBuffer) â€“ Writes bytes from the buffer to the channel
truncate(long) â€“ Truncates the file (or other entity) connected to the channel

FileChannel has advanced features e.g. file region locking, reading/writing bytes from absolute location, mapping file region to memory

#+BEGIN_SRC java
// Defaults to READ
try (SeekableByteChannel sbc = Files.newByteChannel(file)) {
    ByteBuffer buf = ByteBuffer.allocate(10);

    // Read the bytes with the proper encoding for this platform.  If
    // you skip this step, you might see something that looks like
    // Chinese characters when you expect Latin-style characters.
    String encoding = System.getProperty("file.encoding");
    while (sbc.read(buf) > 0) {
        buf.rewind();
        System.out.print(Charset.forName(encoding).decode(buf));
        buf.flip();
    }
} catch (IOException x) {
    System.out.println("caught exception: " + x);


import static java.nio.file.StandardCopyOption.*;

// Create the set of options for appending to the file.
Set<OpenOptions> options = new HashSet<OpenOption>();
options.add(APPEND);
options.add(CREATE);

// Create the custom permissions attribute.
Set<PosixFilePermission> perms =
    PosixFilePermissions.fromString("rw-r------");
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(perms);

// Convert the string to a ByteBuffer.
String s = ...;
byte data[] = s.getBytes();
ByteBuffer bb = ByteBuffer.wrap(data);

try (SeekableByteChannel sbc = Files.newByteChannel(file, options, attr)) {
    sbc.write(bb);
} catch (IOException x) {
    System.out.println("exception thrown: " + x);
}
#+END_SRC

***** OpenOptions
OpenOptions
WRITE â€“ Opens the file for write access.
APPEND â€“ Appends the new data to the end of the file. This option is used with the WRITE or CREATE options.
TRUNCATE_EXISTING â€“ Truncates the file to zero bytes. This option is used with the WRITE option.
CREATE_NEW â€“ Creates a new file and throws an exception if the file already exists.
CREATE â€“ Opens the file if it exists or creates a new file if it does not.
DELETE_ON_CLOSE â€“ Deletes the file when the stream is closed. This option is useful for temporary files.
SPARSE â€“ Hints that a newly created file will be sparse. This advanced option is honored on some file systems, such as NTFS, where large files with data "gaps" can be stored in a more efficient manner where those empty gaps do not consume disk space.
SYNC â€“ Keeps the file (both content and metadata) synchronized with the underlying storage device.
DSYNC â€“ Keeps the file content synchronized with the underlying storage device.


**** Traversing Directories
in files.Files
Path walkFileTree(Path start, FileVisitor<? super Path> visitor)
Path walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth, FileVisitor<?  super Path> visitor)

FileVisitor Interface

| FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) | Invoked just before the elements of the directory are accessed. |
| FileVisitResult visitFile(T file, BasicFileAttributes attrs)        | Invoked when a file is visited.                                 |
| FileVisitResult postVisitDirectory(T dir, IOException exc)          | Invoked when all the elements of the directory are accessed.    |
| FileVisitResult visitFileFailed(T file, IOException exc)            | Invoked when the file cannot be accessed.                       |

FileVisitResult options
CONTINUE
TERMINATE
SKIP_SUBTREE
SKIP_SIBLINGS: It indicates that walking file tree should be stopped for the current directory and its sibling directories.
If it is returned from the preVisitDirectory(), then the containing files/directories are not visited and the postVisitDirectory() is also not visited.
If it is returned from visitFile(), then no further file in the directory is visited.
If it is returned from the postVisitDirectory(), then siblings of the directory are  not visited.

#+BEGIN_SRC java
  import java.io.IOException;
  import java.nio.file.*;
  import java.nio.file.attribute.BasicFileAttributes;

  class MyFileVisitor extends SimpleFileVisitor<Path> {
      public FileVisitResult visitFile(Path path, BasicFileAttributes fileAttributes){
          System.out.println("file name:" + path.getFileName());
          return FileVisitResult.CONTINUE;
      }
      public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes fileAttributes){
          System.out.println("----------Directory name:" + path + "----------");
          return FileVisitResult.CONTINUE;
      }
  }

  public class FileTreeWalk {
      public static void main(String[] args) {
          if(args.length != 1) {
              System.out.println("usage: FileWalkTree <source-path>");
              System.exit(-1);
          }
          Path pathSource = Paths.get(args[0]);
          try {
              Files.walkFileTree(pathSource, new MyFileVisitor());
          }
          catch (IOException e) {
              e.printStackTrace();
          }
      }
  }


#+END_SRC

Globbing for files
#+BEGIN_SRC java
  import java.io.IOException;
  import java.nio.file.*;
  import java.nio.file.attribute.*;

  class MyFileFindVisitor extends SimpleFileVisitor<Path> {
      private PathMatcher matcher;
      public MyFileFindVisitor(String pattern){
          try {
              matcher = FileSystems.getDefault().getPathMatcher(pattern);
          }
          catch(IllegalArgumentException iae) {
              System.err.println("Invalid pattern;did you forget to prefix \"glob:\"? (as in  glob:*.java)");
              System.exit(-1);
          }

      }
      public FileVisitResult visitFile(Path path, BasicFileAttributes fileAttributes){
          find(path);
          return FileVisitResult.CONTINUE;
      }
      private void find(Path path) {
          Path name = path.getFileName();
          if(matcher.matches(name))                        System.out.println("Matching file:" + path.getFileName());
      }
      public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes fileAttributes){
          find(path);
          return FileVisitResult.CONTINUE;
      }
  }

  public class FileTreeWalkFind {
      public static void main(String[] args) {
          if(args.length != 2){
              System.out.println("usage: FileTreeWalkFind <start-path> <pattern to search>");
              System.exit(-1);
          }
          Path startPath = Paths.get(args[0]);
          String pattern = args[1];

          try {
              Files.walkFileTree(startPath, new MyFileFindVisitor(pattern));
              System.out.println("File search completed!");
          }
          catch (IOException e) {
              e.printStackTrace();
          }
      }
  }


#+END_SRC

Watching path for changes
#+BEGIN_SRC java
  import java.io.IOException;
  import java.nio.file.*;

  public class KeepAnEye {
      public static void main(String[] args) {
          Path path = Paths.get("..\\src");
          WatchService watchService = null;
          try {
              watchService = path.getFileSystem().newWatchService();
              path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
          }
          catch (IOException e1) {
              e1.printStackTrace();
          }
          //infinite loop
          for(;;){
              WatchKey key = null;
              try {
                  //The key maybe in ready state(ready to receive events), signed (when one or more events are queued), invalid , key must be reset when in signed state to receive more events
                  //Service watches only one directory, any subdirectories must be separately registered
                  key = watchService.take();
              }
              catch (InterruptedException e) {
                  e.printStackTrace();
              }
              // iterate for each event
              for(WatchEvent<?> event:key.pollEvents()){
                  switch(event.kind().name()){
                  case "OVERFLOW":
                      System.out.println("We lost some events");
                      break;
                  case "ENTRY_MODIFY":
                      System.out.println("File " + event.context() + " is changed!");
                      break;
                  }
              }
              //resetting the key is important to receive subsequent notifications
              key.reset();
          }
      }
  }


#+END_SRC


** JDBC
DB Drivers must be on the classpath for jdbc to be functional

Connection Interface

| Statement createStatement()                     | Creates a Statement object that can be used to send SQL statements to the database.                                                                                                                                                      |
| PreparedStatement  prepareStatement(String sql) | Creates a PreparedStatement object that can contain SQL statements. The SQL statement can have IN parameters; they may contain '?' symbol(s), which are used as placeholders for passing actual values later.                      |
| CallableStatement  prepareCall(String sql)      | Creates a CallableStatement object for calling stored procedures in the database. The SQL statement can have IN or OUT parameters; they may contain '?' symbol(s), which are used as placeholders for passing actual values later. |
| DatabaseMetaData  getMetaData()                 | Gets the DataBaseMetaData object. This metadata contains useful information, such as database schema information, table information, etc., which is especially useful when you don’t know the underlying database.                    |
| Clob createClob()                               | Returns a Clob object (Clob is the name of the interface). CLOB (Character Large Object) is a built-in type in SQL; it can be used to store a column value in a row of a database table.                                                 |
| Blob createBlob()                               | Returns a Blob object (Blob is the name of the interface). BLOB (Binary Large Object) is a built-in type in SQL; it can be used to store a column value in a row of a database table.                                                    |
| void setSchema(String schema)                   | When passed the schema name, it sets this Connection object to the database schema to access.                                                                                                                                            |
| String getSchema()                              | Returns the schema name of the database associated with this Connection object; returns null if no schema is associated with it.                                                                                                         |

#+BEGIN_SRC java
  import java.sql.*;
  // The class attempts to acquire a connection with the database
  class DbConnect {
      public static void main(String[] args) {
          // url points to jdbc protocol : mysql subprotocol; localhost is the address
          // of the server where we installed our DBMS (i.e. on local machine) and
          // 3306 is the port on which we need to contact our DBMS
          String url = "jdbc:mysql://localhost:3306/";
          // we are connecting to the addressBook database we created earlier
          String database = "addressBook";
          // we login as "root" user with password "mysql123"
          String userName = "root";
          String password = "mysql123";
          try (Connection connection = DriverManager.getConnection(url + database, userName, password)){
                  System.out.println("Database connection: Successful");
              }
          catch (Exception e) {
              System.out.println("Database connection: Failed");
              e.printStackTrace();
          }
      }
  }


#+END_SRC

Statement(Connection.createStatement()) -> PreparedStatement(Parametrized Connection.preparedStatement()) -> CallableStatement(Used to execute stored procedures Connection.prepareCall())

executeQuery() for SELECT
executeUpdate() for INSERT,UPDATE,DELETE
execute() for both

*** ResultSet
Represents a sql result table
| void beforeFirst()              | Sets the cursor just before the first row in the ResultSet. |
| void afterLast()                | Sets the cursor just after the last row of the ResultSet.   |
| boolean absolute(int rowNumber) | Sets the cursor to the requested row number absolutely.     |
| boolean relative(int rowNumber) | Sets the cursor to the requested row number relatively.     |
| boolean next()                  | Sets the cursor to the next row of the ResultSet.           |
| boolean previous()              | Sets the cursor to the previous row of the ResultSet.       |

provides get,update methods for primitive Types
e.g. getDouble(int colnum), getDouble(String colname)
getObject(int colnum)

the column index starts at 1

getMetaData().getColumnCount() returns number of columns
#+BEGIN_SRC java
  import java.sql.*;

  // To illustrate how we can update a database
  class DbUpdate {
      public static void main(String[] args) throws SQLException {
          try (Connection connection = DbConnector.connectToDb();
               Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
               ResultSet resultSet = statement.executeQuery("SELECT * FROM contact  WHERE firstName=\"Michael\"")) {
                  // first fetch the data and display it before the update operation
                  System.out.println("Before the update");
                  System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                  while (resultSet.next()) {
                      System.out.println(resultSet.getInt("id") +
                                         "\t" + resultSet.getString("firstName") +
                                         "\t" + resultSet.getString("lastName")
                                         + "\t"+ resultSet.getString("email")
                                         + "\t"+ resultSet.getString("phoneNo"));
                  }
                  // now update the resultSet and display the modified data
                  resultSet.absolute(1); //move cursor to first row
                  resultSet.updateString("phoneNo", "+919976543210");
                  resultSet.updateRow();

                  //insert
                  resultSet.moveToInsertRow();
                  resultSet.updateString("firstName", "John");
                  resultSet.updateString("lastName", "K.");
                  resultSet.updateString("email", "john@abc.com");
                  resultSet.updateString("phoneNo", "+19753186420");
                  resultSet.insertRow();

                  System.out.println("After the update");
                  System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                  resultSet.beforeFirst();
                  while (resultSet.next()) {
                      System.out.println(resultSet.getInt("id") +
                                         "\t" + resultSet.getString("firstName") +
                                         "\t" + resultSet.getString("lastName") +
                                         "\t" + resultSet.getString("email") +
                                         "\t" + resultSet.getString("phoneNo"));
                  }
              }
          catch (SQLException e) {
              e.printStackTrace();
              System.exit(-1);
          }
      }
  }


#+END_SRC

Deleting
#+BEGIN_SRC java
  import java.sql.*;
  // To illustrate how to delete a row in a ResultSet and in the database
  class DbDelete {
      public static void main(String[] args) throws SQLException {
          try (Connection connection = DbConnector.connectToDb();
               Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
               ResultSet resultSet1 = statement.executeQuery("SELECT * FROM contact WHERE firstName=\"John\"")) {
                  if(resultSet1.next()){
                      // delete the first row
                      resultSet1.deleteRow();
                  }
                  resultSet1.close();
                  // now fetch again from the database
                  try (ResultSet resultSet2 = statement.executeQuery("SELECT * FROM contact")) {
                          System.out.println("After the deletion");
                          System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                          while (resultSet2.next()){
                              System.out.println(resultSet2.getInt("id") +
                                                 "\t" +
                                                 resultSet2.getString("firstName") +
                                                 "\t" +
                                                 resultSet2.getString("lastName") +
                                                 "\t" +
                                                 resultSet2.getString("email") +
                                                 "\t" +
                                                 resultSet2.getString("phoneNo"));
                          }
                      }
              }
          catch (SQLException e) {
              e.printStackTrace();
              System.exit(-1);
          }
      }
  }

#+END_SRC


*** Transactions
Methods for conducting transactions in Connection
| void setAutoCommit(boolean autoCommit)     | Sets the auto-commit mode to true or false. By default, Connection objects have auto-commit set to true, and you can set it to false by calling this method with false as the argument value.                                                                                              |
| boolean getAutoCommit()                    | Returns the auto-commit mode value (a true value means auto-commit mode, and a false value means manual commit mode).                                                                                                                                                                      |
| Savepoint setSavepoint()                   | Creates a Savepoint object in the current transaction and returns that object.                                                                                                                                                                                                             |
| Savepoint setSavepoint(String name)        | Same as the previous method, except that the Savepoint object has a name associated with it.                                                                                                                                                                                               |
| void releaseSavepoint(Savepoint savepoint) | Removes the given Savepoint object and the subsequent Savepoint objects from the current transaction.                                                                                                                                                                                      |
| void rollback(Savepoint savepoint)         | Rolls back to the given Savepoint state. In other words, all the changes done after the Savepoint was created will be lost or removed (an undo operation till that Savepoint). Will throw a SQLException if rollback cannot be done  (for example, an invalid Savepoint object is passed). |
| void rollback()                            | Rolls back (undoes) all the changes made in the current transaction. Will throw a SQLException if rollback fails  (e.g., rollback() was called when auto-commit mode is set).                                                                                                              |
| void commit()                              | Makes (commits) all the changes done so far in the transaction to the database.                                                                                                                                                                                                            |

Rolling back changes
#+BEGIN_SRC java
  import java.sql.*;

  // To illustrate how to do commit or rollback
  class DbTransaction {
      public static void main(String[] args) throws SQLException {
          Connection connection = DbConnector.connectToDb();
          ResultSet resultSet1 = null, resultSet2 = null;
          // we're using explicit finally blocks                // instead of try-with-resources statement in this code
          try {
              // for commit/rollback we first need to set auto-commit to false
              connection.setAutoCommit(false);
              Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
              resultSet1 = statement.executeQuery("SELECT * FROM familyGroup");
              resultSet1.moveToInsertRow();
              resultSet1.updateString("nickName", "Sam Uncle");
              // updating here. . . but this change will be lost if a rollback happens
              resultSet1.insertRow();
              System.out.println("First table updated. . .");
              resultSet2 = statement.executeQuery("SELECT * FROM contact");
              resultSet2.moveToInsertRow();
              resultSet2.updateString("firstName", "Samuel");
              resultSet2.updateString("firstName","The great Samuel the billionaire from Washington DC");
              resultSet2.updateString("lastName", "Uncle");
              resultSet2.updateString("email", "sam@abc.com");
              resultSet2.updateString("phoneNo", "+119955331100");
              // updating here. . . but this change will be lost of a rollback happens
              resultSet2.insertRow();
              System.out.println("Both tables updated, committing now.");
              // we're committing the changes for both the tables only now
              connection.commit();
          }
          catch (SQLException e) {
              System.out.println("Something gone wrong, couldn't add a contact in family group");
              // roll back all the changes in the transaction since something has gone wrong
              connection.rollback();
              e.printStackTrace();
          }
          finally {
              if(connection != null) connection.close();
              if(resultSet1 != null) resultSet1.close();
              if(resultSet2 != null) resultSet2.close();
          }
      }
  }


#+END_SRC

Using Savepoints
#+BEGIN_SRC java
    import java.sql.*;

    // To illustrate how to use savepoints with commits and rollbacks
    class DbSavepoint {
        public static void main(String[] args) throws SQLException {
            Connection connection = DbConnector.connectToDb();
            ResultSet resultSet = null;
            // we're using explicit finally blocks                // instead of try-with-resources statement in this code
            try {
                // for commit/rollback we first need to set auto-commit to false
                connection.setAutoCommit(false);
                Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                resultSet = statement.executeQuery("SELECT * FROM familyGroup");
                System.out.println("Printing the contents of the table before inserting");
                while(resultSet.next()) {
                    System.out.println(resultSet.getInt("id") + " " + resultSet.getString("nickName"));
                }

                System.out.println("Starting to insert rows");
                // first insert
                resultSet.moveToInsertRow();
                resultSet.updateString("nickName", "Tom");
                resultSet.insertRow();
                System.out.println("Inserted row for Tom");
                // our first savepoint is here. . .
                Savepoint firstSavepoint = connection.setSavepoint();
                // second insert
                resultSet.moveToInsertRow();
                resultSet.updateString("nickName", "Dick");
                resultSet.insertRow();
                System.out.println("Inserted row for Dick");
                // our second savepoint is here. . . after we inserted Dick                        // we can give a string name for savepoint
                Savepoint secondSavepoint = connection.setSavepoint("SavepointForDick");
                // third insert
                resultSet.moveToInsertRow();
                resultSet.updateString("nickName", "Harry");
                resultSet.insertRow();
                System.out.println("Inserted row for Harry");
                // our thrid savepoint is here. . . for "Harry"
                Savepoint thirdSavepoint = connection.setSavepoint("ForHarry");
                System.out.println("Table updation complete. . .");
                // rollback to the state when Dick was inserted;
                // so the insert for Harry will be lost
                System.out.println("Rolling back to the state where Tom and Dick were inserted");
                connection.rollback(secondSavepoint);
                // commit the changes now and see what happens to the contents of the table
                connection.commit();
                System.out.println("Printing the contents of the table after commit");
                resultSet = statement.executeQuery("SELECT * FROM familyGroup");
                while(resultSet.next()) {
                    System.out.println(resultSet.getInt("id") + " "  + resultSet.getString("nickName"));
                }
            }
            catch (SQLException e) {
                System.out.println("Something gone wrong, couldn't add a contact in family group");
                // roll back all the changes in the transaction since something has gone wrong
                connection.rollback();
                e.printStackTrace();
            }

            finally {
                if(connection != null) connection.close();
                if(resultSet != null) resultSet.close();
            }
        }
    }


#+END_SRC


*** RowSet
Subinterface of ResultSet which provides additional functionality such as event listeners, java bean interaction

                    RowSet
       ________________|______________
      |                               |
   JdbcRowSet                    CachedRowSet
                                      |
                                 WebRowSet
                        ______________|____________
                       |                           |
                   JoinRowSet                FilterRowSet

Factory Instances created through RowSetProvider
newFactory() creates factory based on javax.sql.rowset.RowSetFactory property, if not found raises exception
newFactory(String factoryClass, ClassLoader classloader)

#+BEGIN_SRC java
  import javax.sql.rowset.*;
  import java.sql.*;

  // To illustrate how to use RowSet, RowSetProvider, and RowSetFactory
  class DbQuery5 {
      public static void main(String[] args) {
          String url = "jdbc:mysql://localhost:3306/addressBook";
          String userName = "root";
          String password = "mysql123";
          try {
              // first, create a factory object for rowset
              RowSetFactory rowSetFactory = RowSetProvider.newFactory();
              // create a JDBC rowset from the factory
              JdbcRowSet rowSet = rowSetFactory.createJdbcRowSet();
              rowSet.setUrl(url);
              rowSet.setUsername(userName);
              rowSet.setPassword(password);
              rowSet.setCommand("SELECT * FROM contact");
              rowSet.execute();
              System.out.println("id \tfName \tlName \temail \t\tphoneNo");
              while (rowSet.next()){
                  System.out.println(rowSet.getInt("id")
                                     + "\t" + rowSet.getString("firstName")
                                     + "\t" + rowSet.getString("lastName")
                                     + "\t" + rowSet.getString("email")
                                     + "\t" + rowSet.getString("phoneNo"));
              }
          }
          catch (SQLException sqle) {
              sqle.printStackTrace();
          }
      }
  }

stmt = con.createStatement(
           ResultSet.TYPE_SCROLL_SENSITIVE,
           ResultSet.CONCUR_UPDATABLE);
rs = stmt.executeQuery("select * from COFFEES");
jdbcRs = new JdbcRowSetImpl(rs);

jdbcRs = new JdbcRowSetImpl();
    jdbcRs.setCommand("select * from COFFEES");
    jdbcRs.setUrl("jdbc:myDriver:myAttribute");
    jdbcRs.setUsername(username);
    jdbcRs.setPassword(password);
    jdbcRs.execute();

#+END_SRC


** Localization

*** Locale Class
java.util.Locale
| static Locale[] getAvailableLocales()    | Returns a list of available locales (i.e., installed locales) supported by the JVM.      |
| static Locale getDefault()               | Returns the default locale of the JVM.                                                   |
| static void setDefault(Locale newLocale) | Sets the default locale of the JVM.                                                      |
| String getCountry()                      | Returns the country code for the locale object.                                          |
| String getDisplayCountry()               | Returns the country name for the locale object.                                          |
| String getLanguage()                     | Returns the language code for the locale object.                                         |
| String getDisplayLanguage()              | Returns the language name for the locale object.                                         |
| String getVariant()                      | Returns the variant code for the locale object.                                          |
| String getDisplayVariant()               | Returns the name of the variant code for the locale object.                              |
| String toString()                        | Returns a String composed of the codes for the locale's language, country, variant, etc. |

Locale name format
language + "_" + country + "_" + (variant + "_#" | "#") + script + "-" + extensions e.g.  th_TH_TH_#u-nu-thai

#+BEGIN_SRC java
  import java.util.Locale;

  public class LocaleDetails {
          public static void main(String args[]) {
                  Locale.setDefault(Locale.CANADA_FRENCH);
                  Locale defaultLocale = Locale.getDefault();
                  System.out.printf("The default locale is %s %n", defaultLocale);
                  System.out.printf("The default language code is %s and the name is %s %n", defaultLocale.getLanguage(), defaultLocale.getDisplayLanguage());
                  System.out.printf("The default country code is %s and the name is %s %n", defaultLocale.getCountry(), defaultLocale.getDisplayCountry());
                  System.out.printf("The default variant code is %s and the name is %s %n", defaultLocale.getVariant(), defaultLocale.getDisplayVariant());
          }
   }


#+END_SRC


*** Resource Bundles
                                                               ResourceBundle(Abstract)
                        _________________________________________________|_____________________________________________
                       |                                                                                               |
   PropertyResourceBundle(reads properties from a file)                                      ListResourceBundle(reads properties from getContents() which returns Object[][])

| Object getObject(String key)                                                          | Returns the value mapped to the given key. Throws a MissingResourceException if no object for a given key is found.                                                                                                                                           |
| static ResourceBundle getBundle(String baseName)                                      |                                                                                                                                                                                                                                                               |
| static final ResourceBundle  getBundle(String baseName, Locale locale)                |                                                                                                                                                                                                                                                               |
| final ResourceBundle getBundle(String baseName, Locale targetLocale, Control control) | Returns the ResourceBundle for the given baseName, locale, and control; throws a MissingResourceException if no matching resource bundle is found. The Control instance is meant for controlling or obtaining info about the resource bundle loading process. |
| String getString(String key)                                                          | Returns the value mapped to the given key; equivalent to casting the return value from getObject() to String. Throws a MissingResourceException if no object for a given key is found. Throws ClassCastException if the object returned is not a String.      |


#+BEGIN_SRC java
  /**
     D:\ > type ResourceBundle.properties
     Greeting = Hello
     D:\ > type ResourceBundle_ar.properties
     Greeting = As-Salamu Alaykum
     D:\ > type ResourceBundle_it.properties
     Greeting = Ciao
   ,*/

  import java.util.*;

  public class LocalizedHello {
          public static void main(String args[]) {
                  Locale currentLocale = Locale.getDefault();
                  ResourceBundle resBundle = ResourceBundle.getBundle("ResourceBundle", currentLocale);
                  System.out.printf(resBundle.getString("Greeting"));
          }
   }

#+END_SRC

example using ListResourceBundle
#+BEGIN_SRC java
  import java.util.*;
  // default US English version
  public class ResBundle extends ListResourceBundle {
      public Object[][] getContents() {
          return contents;
      }
      static final Object[][] contents = {
          { "MovieName", "Avatar" },
          { "GrossRevenue", (Long) 2782275172L }, // in US dollars
          { "Year", (Integer)2009 }
      };
  }

  public class LocalizedHello2 {
      public static void printMovieDetails(ResourceBundle resBundle) {
          String movieName = resBundle.getString("MovieName");
          Long revenue = (Long)(resBundle.getObject("GrossRevenue"));
          Integer year = (Integer) resBundle.getObject("Year");
          System.out.println("Movie " + movieName + "(" + year ")" + " grossed " + revenue );
      }
      public static void main(String args[]) {
          // print the largest box-office hit movie for default (US) locale
          Locale locale = Locale.getDefault();
          printMovieDetails(ResourceBundle.getBundle("ResBundle", locale));
          // print the largest box-office hit movie for Italian locale
          locale = new Locale("it", "IT", "");
          printMovieDetails(ResourceBundle.getBundle("ResBundle", locale));
      }

  }

#+END_SRC

**** Naming convention
packagequalifier.bundlename + "_" + language + "_" + country + "_" + (variant + "_#" | "#")

 packagequalifier: The name of the package (or the subpackages) in which the resource bundle is provided.
 bundlename: The name of the resource bundle that you'll use in the program to refer and load it.
 language: A two-letter abbreviation typically given in lowercase for the locale's language (in rare cases, it could be three letters as well).
 country: A two letter abbreviation typically given in uppercase for the locale's country (in rare cases, it could be three letters as well).
 variant: An arbitrary list of variants (in lowercase or uppercase) to differentiate locales when you need more than one locale for a language and country combination.

e.g. localization.examples.AppBundle_en_US_Oracle_exam

When given a resource bundle name, the system tries to find a matching bundle dropping each part of the name separated by underscore.
Lookup process can be customized using ResourceBundle.control

#+BEGIN_SRC java
  import java.util.*;

  // Extend ResourceBundle.Control and override getCandidateLocales method // to get the list of candidate locales that Java searches for
  class TalkativeResourceBundleControl extends ResourceBundle.Control {
      // override the default getCandidateLocales method to print // the candidate locales first
      public List < Locale > getCandidateLocales(String baseName, Locale locale) {
          List < Locale > candidateLocales = super.getCandidateLocales(baseName, locale);
          System.out.printf("Candidate locales for base bundle name %s and locale %s %n", baseName, locale.getDisplayName());
          for(Locale candidateLocale : candidateLocales) {
              System.out.println(candidateLocale);
          }
          return candidateLocales;
      }
  }

  // Use a helper method loadResourceBundle to load a bundle given the bundle name and locale
  class CandidateLocales {
      public static void loadResourceBundle(String resourceBundleName, Locale locale) {
          // Pass an instance of TalkativeResourceBundleControl // to print candidate locales
          ResourceBundle resourceBundle = ResourceBundle.getBundle(resourceBundleName, locale, new TalkativeResourceBundleControl());
          String rbLocaleName = resourceBundle.getLocale().toString();
          // if the resource bundle locale name is empty, // it means default property file
          if(rbLocaleName.equals("")) {
              System.out.println("Loaded the default property file with name: " + resourceBundleName);
          }
          else {
              System.out.println("Loaded the resource bundle for the locale: " + resourceBundleName + "." + rbLocaleName);
          }
      }
      public static void main(String[] args) {
          // trace how ResourceBundle_it_IT_Rome.properties is resolved
          loadResourceBundle("ResourceBundle", new Locale("it", "IT", "Rome"));
      }
  }


#+END_SRC



To invoke application with a different default locale
D:\>java -Duser.language = it -Duser.region = IT LocalizedHello


*** NumberFormat
Used for converting numeric values to strings and vice versa based on locale.

| String format(double number),String format(long number) | Formats the number according to the NumberFormat’s locale. The first two overloaded methods use an implicit StringBuffer, whereas the last two use an explicit StringBuffer to build the String. |
| Number parse(String source)                            | Parses the number from the given String. It returns a Long or Double instance depending on the value of the number given in source.  Throws a ParseException if the parse fails.                    |
| static Locale[] getAvailableLocales()                  | Returns the list of the locales supported by the Java runtime for number formatting.                                                                                                                |
| static NumberFormat getInstance()                      | Factory method that returns a NumberFormat object for the default locale.                                                                                                                           |
| Currency getCurrency()                                 | Returns the currency instance used by this NumberFormat object.                                                                                                                                     |
| static NumberFormat getCurrencyInstance()              | Returns the instance of NumberFormat suitable for currency formatting purposes; an overloaded version of this method takes a Locale as an argument.                                                 |
| static NumberFormat getIntegerInstance()               | Returns the instance of NumberFormat suitable for use for formatting integer numbers; an overloaded version of this method takes a Locale as an argument.                                           |
| static NumberFormat getPercentInstance()               | Returns the instance of NumberFormat suitable for use for formatting for percentages; an overloaded version of this method takes a Locale as an argument.                                           |

#+BEGIN_SRC java
  import java.util.*;
  import java.text.*;

  // class to demonstrate how to format or parse numbers for a particular locale
  class FormatNumber {
      public static void main(String []args) {
          long tenMillion = 10_000_000L;
          // first print ten million in German locale
          NumberFormat germanFormat = NumberFormat.getInstance(Locale.GERMANY);
          String localizedTenMillion = germanFormat.format(tenMillion);
          System.out.println("Ten million in German locale is " + localizedTenMillion);

          // now, scan the value ten million given in German locale
          try {
              Number parsedAmount = germanFormat.parse(localizedTenMillion);
              if(tenMillion == parsedAmount.longValue()) {
                  System.out.println("Successfully parsed the number for the locale");
              }
          }
          catch (ParseException pe) {
              System.err.println("Error: Cannot parse the number for the locale");
          }
      }
  }


#+END_SRC

**** Using Currency class
| int getNumericCode()                             | Returns ISO 4217 numeric code for the currency.                                                                           |
| int getDefaultFractionDigits()                   | Returns the default number of digits used with the currency, such as zero for the Japanese Yen and two for the US Dollar. |
| String getDisplayName()                          | Returns the readable description of the Currency for the underlying locale, for example, US Dollar.                       |
| String getDisplayName(Locale)                    | Returns the readable description of the Currency for the given locale.                                                    |
| static Currency getInstance(String currencyCode) | Returns the Currency object corresponding to the given currency code.                                                     |
| static Currency getInstance(Locale locale)       | Returns the Currency object corresponding to the given Locale object.                                                     |
| static Set < Currency > getAvailableCurrencies() | Get the list of Currency instances available in the JDK.                                                                  |
| String getSymbol()                               | Returns the currency symbol, if any; otherwise, returns the currency code.                                                |
| String getSymbol(Locale)                         | Returns the currency symbol for the given Locale object.                                                                  |
| String getCurrencyCode()                         | Returns the currency code (ISO 4217) for locale of the Currency instance.                                                 |


#+BEGIN_SRC java
  import java.util.*;
  import java.text.*;

  // Ilustrates how to use NumberFormat class to get Currency instance
  class LocalizedCurrency {
      public static void main(String []args) {
          long tenMillion = 10000000L;
          // this is ten million
          Locale [] locales = { Locale.CANADA, Locale.FRANCE, Locale.GERMANY, Locale.TAIWAN };
          // for each of the four locales, // print the currency amount as it looks in that locale
          for(Locale locale : locales) {
              System.out.println("Ten million in " + locale.getDisplayName() + " is " + NumberFormat.getCurrencyInstance(locale).format(tenMillion));
          }
      }
  }


#+END_SRC


*** DateFormat
| String format(Date date)                | Formats the given date for the default locale and returns a textual representation. Its overloaded version takes a StringBuffer and position as arguments and returns a StringBuffer object; useful if an existing StringBuffer needs to be formatted for date. |
| Date parse(String source)               | Reads the given String according to the default locale conventions to return a Date object; throws ParseException if it fails. It has an overloaded version that takes ParsePosition (the position from which to parse the String) as an additional argument.   |
| String format(Date date)                | Formats the given date for the default locale and returns a textual representation.                                                                                                                                                                             |
| static Locale[] getAvailableLocales()   | Returns an array of Locales that are supported by the Java runtime for date/time formatting.                                                                                                                                                                    |
| static DateFormat getInstance()         | Returns the default DateFormat instance that supports both date and time; it uses DateFormat.SHORT style for both date and time.                                                                                                                                |
| static DateFormat getDateInstance()     | Returns the DateFormat instance suitable for processing dates for default locale; its two overloaded versions take style and Locale as additional arguments.                                                                                                    |
| static DateFormat getTimeInstance()     | Returns the DateFormat instance suitable for processing time for a default locale; its two overloaded versions take style and Locale as additional arguments.                                                                                                   |
| static DateFormat getDateTimeInstance() | Returns the DateFormat instance suitable for processing both date and time for a default locale; its two overloaded versions take style and Locale as additional arguments.                                                                                     |


#+BEGIN_SRC java
  import java.util.*;
  import java.text.*;

  // Demonstrates the use of constants in DateFormat that determines the display style
  class DateStyleFormats {
      public static void main(String []args) {
          Date now = new Date();
          int [] dateStyleFormats = {
              DateFormat.SHORT, DateFormat.MEDIUM, DateFormat.LONG, DateFormat.FULL, DateFormat.DEFAULT};
          System.out.println("Today's date in different styles are: ");

          // print today's date in all four formats plus                // the default format in the default Locale
          for(int dateStyleFormat : dateStyleFormats) {
              DateFormat dateFormat = DateFormat.getDateInstance(dateStyleFormat);
              System.out.println(dateFormat.format(now));
          }
      }
  }



#+END_SRC

**** SimpleDateFormat
G     Era (BC/AD)
y     Year
Y     Week year
M     Month (in year)
w     Week (in year
W     Week (in month)
D     Day (in year)
d     Day (in month)
F     Day of week in month
E     Day name in week
u     Day number of week (value range 1-7)

a     Marker for the text am/pm marker
H     Hour (value range 0-23)
k     Hour (value range 1-24)
K     Hour in am/pm (value range 0-11)
h     Hour in am/pm (value range 1-12)
m     Minute
s     Second
S     Millisecond
z     Time zone  (general time zone format)

#+BEGIN_SRC java

  import java.util.*;
  import java.text.*;

  // Use SimpleDateFormat for creating custom date and time formats as a pattern string
  class PatternStringExample {
      public static void main(String []args) {
          String pattern = "dd-MM-yy";
          /* d for day, M for month, y for year */
          SimpleDateFormat formatter = new SimpleDateFormat(pattern);
          // the default Date constructor initializes to current date/time
          System.out.println(formatter.format(new Date()));
      }
  }


#+END_SRC


** Generics


Paramterized methods
#+BEGIN_SRC java
public class Util {
    // Generic static method
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}

Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.<Integer, String>compare(p1, p2);
boolean same = Util.compare(p1, p2); //Type inferred
#+END_SRC

#+BEGIN_SRC java
  //Class using generics
//primitives cannot be used parameters
  class Test<T> {
      T t;
      Test(T arg) {
          t = arg;
      }
  }
  Test<Integer> test = new Test<Integer>(10);

  // Method using generics

  public <T> void method(T arg) {
      doSomething(arg);
  }
#+END_SRC

Multiple Bounds
#+BEGIN_SRC java
Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D <T extends A & B & C> { /* ... */ }
//If bound A is not specified first, you get a compile-time error:

class D <T extends B & A & C> { /* ... */ }  // compile-time error
#+END_SRC

*** Type Inference
Type parameters can be inferred using the context
<> can be used to signal to the compiler to use type inference
e.g. List<String> list = new List<>();

Same thing for methods e.g. return type
static <T> List<T> emptyList();

List<String> listOne = Collections.emptyList();
or arguments
boolean same = Util.compare(p1, p2); //Type inferred

*** Wildcards
Subtyping does not work when assigning to reference using generics
e.g. List<Number> test = new List<Integer>(); //fails
Declaration with <> implies Object type

but works with parameterized methods?
Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK

but does work when using wildcards
List<?> test = new List<Integer>();

Use wildcards when functionality doesn't depend on the type parameter

however modifying a reference declared with a wildcard fails e.g. test.add(10), only accessors are allowed

Wildcard declarations can be bounded
e.g. List<? extends Number> test = new List<Integer>();
<? extends Interface>
or List<? super Integer> test = new List<Integer>(); //Bound inclusive

- You cannot instantiate a generic type using new operator. For example, assuming mem is a field, the following statement will result in a compiler error:
T mem = new T();          // wrong usage - compiler error

- You cannot instantiate an array of a generic type. For example, assuming mem is a field, the following statement will result in a compiler error:
T[] amem = new T[100];    // wrong usage - compiler error

- You can declare non-static fields of type T, but not of static fields of type T. For example,
class X<T> {
  T instanceMem;          // okay
  static T statMem;       // wrong usage - compiler error
}

- It is not possible to have generic exception classes; as a result, the following will not compile:
class GenericException<T> extends Throwable { } // wrong usage - compiler error

- You cannot instantiate a generic type with primitive types in other words,
List<int> cannot be instantiated. However, you can use boxed primitive types.
The meaning of "extends" and "super" changes in the context of generics. For instance, when you say <? extends X>, you refer to all types that extend X and the type X itself.




** Type System
Single Inheritance

Classes can be loaded by different class loaders and the runtime type of an object is a combination of the compile type and the classloader
Parametrized types can be defined
e.g. List<? extends [Class]> list;

@Override annotation can be used both for overridden superclass methods as well as interface methods which have been implemented. Acts as a hint to the compiler.


*** Method dispatching
1. The compiler always tries to choose the most specific method available with least number of modifications to the arguments.
2. Java designers have decided that old code should work exactly as it used to work before boxing-unboxing functionality became available.
3. Widening is preferred to boxing/ unboxing (because of rule 2), which in turn, is preferred over var-args.



*** Primitives
primitives are auto boxed/unboxed
--k means decrement k before evaluating rest of the expression
k-- means evaluate the overall expression first.

*** Classes
Classes really allow us to do the basic association of object-oriented programming, which is to associate some col- lection of data with the code that is used to manipulate that data. The association of inheritance allows us to extend both the set of data that is clustered together and the code that manipulates the data. When we extend one class with another class, we can add data to the collection that is associated, add or replace implementations of the methods that manipulate the data, or simply reuse the code that was written for the class being extended.


*** Interfaces
User Interface of an object
Good idea to define logic of a method in terms of other class methods
And use those relationships to write tests

The good part about Java's type system is that the separation between interface and class allows us to do our semantic design (which has to do with interfaces) separately from our class design (which has to do with implementations). Such a separation allows us to think about the meaning without thinking about how we are going to implement that meaning, simplifying both tasks.

Interfaces are used to define sets of interrelated operations that, taken together, form a unit of meaning in an application. An interface tells us a minimum of what an object does, and is the way to define arguments and return values for a method. Methods require as arguments objects that do at least what the interfaces specify, and methods return an object that does at least what the interface specified as the return value requires. Classes, on the other hand, allow us to define a set of related data, and to associate that data with the code that is used to manipulate that data.



** Exceptions
initCause(), getCause() for wrapped exceptions

Can't have subclasses/superclasses in the bitwise or catch expression

 if you rethrow an exception from a catch block, you can throw a type that the try block can throw but no previous catch handles has handled it.
also, the rethrown exception type need not be same as the catch type parameter; it can be a subtype of the catch parameter.

In a try with resources block, if the close method in the implicit final block throws a exception and the try body throws a exception as well then the close exception is supressed.

If exceptions are thrown in both the catch and finally blocks then the finally exception is thrown, the other is lost.

Implement throwable interface
Any throwable exceptions must be in the method signature.
Order catch clauses so that subclasses of exception are caught first.
A RuntimeException can be thrown at any time, and does not need to be declared as part of the signature of a method. Further, since it can be thrown at any time, the code that might receive a thrown RuntimeException does not have to have a catch clause for those exceptions (otherwise, all code would need to be wrapped in a try block).


** Packages
declares namespace
package com.umraiya.jaideep;

protected members of class are accessible by any field or method in the same package as well as subclasses
if no access level is defined the member is package accessible but not necessarily accessible through subclass in a different package?

Interfaces should preferably be organized in a package separate from concrete classes

Source files must organized in the file system corresponding to the package i.e. com/jumraiya/jaideep for com.umraiya.jaideep
*** Default (nameless) Package
If there is no package statement in the source file, the class is assumed to be created in a default package that has no name.
In this case, all the types created in this default package will be available to this class without any import statement.
However, note that this default package cannot be imported in classes that belong to any other package at all, not even with any sort of import statement.






** Concurrency

*** Deadlock, LiveLock
DeadLock: when two threads hold locks that the other requires and consequently wait indefinitely

Livelock: when two threads cause each other to keep repeating some tasks resulting in a perpetual cycle.


*** Threads
| Thread currentThread()                             | Static method Returns reference to the current thread.                                                                                                                                                                                                            |
| String getName()                                   | Instance method Returns the name of the current thread.                                                                                                                                                                                                           |
| int getPriority()                                  | Instance method Returns the priority value of the current thread.                                                                                                                                                                                                 |
| void join(), void join(long), void join(long, int) | Overloaded  instance methods The current thread invoking join on another thread waits until the other thread dies. You can optionally give the timeout in milliseconds (given in long) or timeout in milliseconds as well as nanoseconds (given in long and int). |
| void run()                                         | Instance method Once you start a thread (using the start() method), the run() method will be called when the thread is ready to execute.                                                                                                                          |
| void setName(String)                               | Instance method Changes the name of the thread to the given name in the argument.                                                                                                                                                                                 |
| void setPriority(int)                              | Instance method Sets the priority of the thread to the given argument value.                                                                                                                                                                                      |
| void sleep(long) void sleep(long, int)             | Overloaded static methods Makes the current thread sleep for given milliseconds (given in long) or for given milliseconds and nanoseconds (given in long and int).                                                                                                |
| void start()                                       | Instance method Starts the thread; JVM calls the run() method of the thread.                                                                                                                                                                                      |
| String toString()                                  | Instance method Returns the string representation of the thread; the string has the thread’s name, priority, and its group.                                                                                                                                    |

Concurrency related functions in Object

| void wait(), void wait(long), void wait(long, int) | Overloaded instance  methods The current thread should have acquired a lock on this object before calling any of the wait methods. If wait() is called, the thread waits infinitely until some other thread notifies (by calling the notify()/notifyAll() method) for this lock. The method wait(long) takes milliseconds as an argument. The thread waits till it is notified or the timeout happens. The wait(long, int) method is similar to wait(long) and additionally takes nanoseconds as an argument. |
| void notify()                                      | Instance method The current thread should have acquired a lock on this object before calling notify(). The JVM chooses a single thread that is waiting on the lock and wakes it up.                                                                                                                                                                                                                                                                                                                           |
| void notifyAll()                                   | Instance method The current thread should have acquired a lock before calling notifyAll(). The JVM wakes up all the threads waiting on a lock.                                                                                                                                                                                                                                                                                                                                                                |


never call run() method directly
join() can be used on a different thread to wait until it has finished executing

Use ThreadLocalRandom to generate random numbers

**** States
can be retrieved using getState()
NEW -> RUNNABLE -> TERMINATED


                RUNNABLE
      _____________|_________________________________________
     |             |                   |                     |
   WAITING       TIMED_WAITING      BLOCKED             TERMINATED
   (wait(),join())                  (acquiring lock)    (Thread finished)

Starting a thread twice will throw a IllegalMonitorStateException



*** AtomicInteger/Long
| AtomicInteger()                                                  | Creates an instance of AtomicInteger with initial value 0.                                                                                                         |
| AtomicInteger(int initVal)                                       | Creates an instance of AtomicInteger with initial value initVal.                                                                                                   |
| int get()                                                        | Returns the integer value held in this object. void set(int newVal) Resets the integer value held in this object to newVal.                                        |
| int getAndSet(int newValue)                                      | Returns the current int value held in this object and sets the value held in this object to newVal.                                                                |
| boolean compareAndSet (int expect, int update)                   | Compares the int value of this object to the expect value, and if they are equal, sets the int value of this object to the update value.                           |
| int getAndIncrement()                                            | Returns the current value of the integer value in this object and increments the integer value in this object. Similar to the behavior  of i++ where i  is an int. |
| int getAndDecrement()                                            | Returns the current value of the integer value in this object and decrements the integer value in this object. Similar to the behavior  of i-- where i  is an int. |
| int getAndAdd(int delta)                                         | Returns the integer value held in this object and adds given delta value to the integer value.                                                                     |
| int incrementAndGet()                                            | Increments the current value of the integer value in this object and returns that value. Similar to the behavior of ++i where i is an int.                         |
| int decrementAndGet()                                            | Decrements the current integer value in this object and returns that value. Similar to behavior of --i where i is an int.                                          |
| int addAndGet(int delta)                                         | Adds the delta value to the current value of the integer in this object and returns that value.                                                                    |
| int intValue() long longValue() float floatValue() doubleValue() | Casts the current int value of the object and returns it as int, long, float, or double values.                                                                    |


*** Collections
| BlockingQueue         | This interface extends the Queue interface. In BlockingQueue, if the queue is empty, it waits (i.e., blocks) for an element to be inserted, and if the queue is full, it waits for an element to be removed from the queue. |
| ArrayBlockingQueue    | This class provides a fixed-sized array based implementation of the BlockingQueue interface.                                                                                                                                |
| LinkedBlockingQueue   | This class provides a linked-list-based implementation of the BlockingQueue interface.                                                                                                                                      |
| DelayQueue            | This class implements BlockingQueue and consists of elements that are of type Delayed. An element can be retrieved from this queue only after its delay period.                                                             |
| PriorityBlockingQueue | Equivalent to java.util.PriorityQueue, but implements the BlockingQueue interface.                                                                                                                                          |
| SynchronousQueue      | This class implements BlockingQueue. In this container, each insert() by a thread waits (blocks) for a corresponding remove() by another thread and vice versa.                                                             |
| LinkedBlockingDeque   | This class implements BlockingDeque where insert and remove operations could block; uses a linked-list for implementation.                                                                                                  |
| ConcurrentHashMap     | Analogous to Hashtable, but with safe concurrent access and updates.                                                                                                                                                        |
| ConcurrentSkipListMap | Analogous to TreeMap, but provides safe concurrent access and updates.                                                                                                                                                      |
| ConcurrentSkipListSet | Analogous to TreeSet, but provides safe concurrent access and updates.                                                                                                                                                      |
| CopyOnWriteArrayList  | Similar to ArrayList, but provides safe concurrent access. When the ArrayList is updated, it creates a fresh copy of the underlying array.                                                                                  |
| CopyOnWriteArraySet   | A Set implementation, but provides safe concurrent access and is implemented using CopyOnWriteArrayList. When the container is updated, it creates a fresh copy of the underlying array.                                    |



*** Locks
void lock() Acquires the lock.

| boolean tryLock()                        | Acquires the lock and returns true if the lock is available; if the lock is not available, it does not acquire the lock and returns false. |
| boolean tryLock(long time,TimeUnit unit) | Same as the previous method tryLock(), but waits for the given waiting time before failing to acquire the lock and returns false.          |
| void lockInterruptibly()                 | Acquires a lock; during the process of a acquiring the lock, if another thread interrupts it, this method throws an InterruptedException   |
| Condition newCondition()                 | Returns a Condition object associated with this Lock object. void unlock() Releases the lock.                                              |

ReentrantLock implements ReadWriteLock interface which allows for separate locks for reading and writing
readLock(), writeLock()


#+BEGIN_SRC java
  Lock lock = /* get Lock type instance */;
  lock.lock();
  try {
      // critical section
  }
  finally {
      lock.unlock();
  }

  Lock lock = /* get Lock type instance */;
  if(lock.tryLock()) {
      try {
          // critical section
      }
      finally {
          lock.unlock();
      }
  } else {
  }

#+END_SRC

#+BEGIN_SRC java
  import java.util.concurrent.locks.*;

  // This class simulates a situation where only one ATM machine is available and
  // and five people are waiting to access the machine. Since only one person can
  // access an ATM machine at a given time, others wait for their turn
  class ATMMachine {
      public static void main(String []args) {
          // A person can use a machine again, and hence using a "reentrant lock"
          Lock machine = new ReentrantLock();
          // list of people waiting to access the machine
          new Person(machine, "Mickey");
          new Person(machine, "Donald");
          new Person(machine, "Tom");
          new Person(machine, "Jerry");
          new Person(machine, "Casper");
      }
  }

  // Each Person is an independent thread; their access to the common resource
  // (the ATM machine in this case) needs to be synchronized using a lock
  class Person extends Thread {
      private Lock machine;
      public Person(Lock machine, String name) {
          this.machine = machine;
          this.setName(name);
          this.start();
      }
      public void run() {
          try {
              System.out.println(getName() + " waiting to access an ATM machine");
              machine.lock();
              System.out.println(getName() + " is accessing an ATM machine");
              Thread.sleep(1000);
              // simulate the time required for withdrawing amount
          }
          catch(InterruptedException ie) {
              System.err.println(ie);
          }
          finally {
              System.out.println(getName() + " is done using the ATM machine");
              machine.unlock();
          }
      }
  }


#+END_SRC

**** Conditions
Has wait(), signal(), signalAll() methods analogous to Wait/notify

Tied to a lock, which is used to concurrently by reader and writer to access condition.

#+BEGIN_SRC java
  import java.util.concurrent.locks.*;

  // This class simulates arrival of trains in a railway station.
  class RailwayStation {
      // A common lock for synchronization
      private static Lock station = new ReentrantLock();
      // Condition to wait or notify the arrival of Joe in the station
      private static Condition joeArrival = station.newCondition();
      // Train class simulates arrival of trains independently
      static class Train extends Thread {
          public Train(String name) {
              this.setName(name);
          }
          public void run() {
              station.lock();
              try {
                  System.out.println(getName() + ": I've arrived in station ");
                  if(getName().startsWith("IC1122")) {
                      // Joe is coming in train IC1122 - he announces it to us
                      joeArrival.signalAll();
                  }
              }
              finally {
                  station.unlock();
              }
          }
      }

      // Our wait in the railway station for Joe is simulated by this thread.
      // Once we get notification from Joe
      // that he has arrived, we pick-him up and go home
      static class WaitForJoe extends Thread {
          public void run() {
              System.out.println("Waiting in the station for IC1122 in which Joe is coming");
              station.lock();
              try {
                  // await Joe's train arrival
                  joeArrival.await();
                  // if this statement executes, it means we got a train arrival signal
                  System.out.println("Pick up Joe and go home");
              }
              catch(InterruptedException ie) {
                  ie.printStackTrace();
              }
              finally {
                  station.unlock();
              }
          }
      }
      // first create a thread that waits for Joe to arrive and then create new Train threads
      public static void main(String []args) throws InterruptedException {
          // we are waiting before the trains start coming
          new WaitForJoe().start();
          // Trains are separate threads - they can arrive in any order
          new Train("IC1234 - Paris to Munich").start();
          new Train("IC2211 - Paris to Madrid").start();
          new Train("IC1122 - Madrid to Paris").start();
          new Train("IC4321 - Munich to Paris").start();
      }
  }

  //Here is the output of this program:
  //Waiting in the station for IC1122 in which Joe is coming
  //IC1234 - Paris to Munich: I've arrived in station
  //IC1122 - Madrid to Paris: I've arrived in station IC2211 - Paris to Madrid: I've arrived in station
  //Pick up Joe and go home
  //IC4321 - Munich to Paris: I've arrived in station


#+END_SRC

#+BEGIN_SRC java
  import java.util.concurrent.locks.*;

  // this implements a fixed size queue with size determined at the time of creation. I/ if remove() is called
  // when there are no elements, then the queue blocks (i.e., waits) until an element is inserted.
  // If insert() is called when the queue is full, then the queue blocks until an element is removed
  class BlockerQueue {
      // remember the max size of the queue
      private int size = 0;
      // array to store the elements in the queue
      private Object elements[];
      // pointer that points to the current element in the queue
      private int currPointer = 0;
      // internal lock used for synchronized access to the BlockerQueue
      private Lock internalLock = new ReentrantLock();
      // condition to wait for when queue is empty that makes use of the common lock
      private Condition empty = internalLock.newCondition();
      // condition to wait for when queue is full that makes use of the common lock
      private Condition full =  internalLock.newCondition();
      public BlockerQueue(int size) {
          this.size = size;
          elements = new Object[size];
      }
      // remove an element if available;or if there are no elements in the queue,
      // await insertion of an element. Once an element is inserted, notify to any threads
      // waiting for insertion in a full queue
      public Object remove() {
          Object element = null;
          internalLock.lock();

          try {
              if(currPointer == 0) {
                  System.out.println("In remove(): no element to remove, so waiting  for insertion");
                  // cannot remove - no elements in the queue;
                  // so block until an element is inserted
                  empty.await();
                  // if control reaches here, that means some thread completed
                  // calling insert(), so proceed to remove that element
                  System.out.println("In remove(): got notification that an element has  got inserted");
              }
              // decrement the currPointer and then get the element
              element = elements[--currPointer];
              System.out.println("In remove(): removed the element " + element);
              // an element is removed, so there is space for insertion
              // so notify any threads waiting to insert
              full.signalAll();
              System.out.println("In remove(): signalled that there is space for insertion");
          }
          catch(InterruptedException ie) {
              ie.printStackTrace();
          }
          finally {
              internalLock.unlock();
          }
          return element;
      }
      // insert an element if there is space for insertion. if queue is full,
      // await for remove() to be called and get signal to proceed for insertion.
      // after insertion, signal any awaiting threads in case of an empty queue.
      public void insert(Object element) {
          internalLock.lock();
          try {
              if(currPointer == size) {
                  System.out.println("In insert(): queue is full, so waiting for removal");
                  // cannot insert - the queue is full;
                  // so block until an element is removed
                  full.await();
                  // if control reaches here, that means some thread completed
                  // calling remove(), so proceed to insert this element
                  System.out.println("In insert(): got notification that remove got called, so proceeding to insert the element");
              }
              // get the element and after that decrement the currPointer
              elements[currPointer++] = element;
              System.out.println("In insert(): inserted the element " + element);
              // an element is inserted, so any other threads can remove it...
              // so notify any threads waiting to remove
              empty.signalAll();
              System.out.println("In insert(): notified that queue is not empty");

          }
          catch(InterruptedException ie) {
              ie.printStackTrace();
          }
          finally {
              internalLock.unlock();
          }
      }
  }

  class BlockerQueueTest1 {
      public static void main(String []args) {
          final BlockerQueue blockerQueue = new BlockerQueue(2);
          new Thread() {
              public void run() {
                  System.out.println("Thread1: attempting to remove an item from the queue ");
                  Object o = blockerQueue.remove();
              }
          }.start();
          new Thread() {
              public void run() {
                  System.out.println("Thread2: attempting to insert an item to the queue");
                  blockerQueue.insert("one");
              }
          }.start();
      }
  }

  //This test code prints the following:
  //Thread1: attempting to remove an item from the queue
  //In remove(): no element to remove, so waiting for insertion
  //Thread2: attempting to insert an item to the queue
  //In insert(): inserted the element one
  //In insert(): notified that queue is not empty
  //In remove(): got notification that an element has got inserted
  //In remove(): removed the element one
  //In remove(): signalled that there is space for insertion

  class BlockerQueueTest2 {
      public static void main(String []args) {
          final BlockerQueue blockerQueue = new BlockerQueue(3);
          blockerQueue.insert("one");
          blockerQueue.insert("two");
          blockerQueue.insert("three");
          new Thread() {

              public void run() {
                  System.out.println("Thread2: attempting to insert an item to the queue");
                  blockerQueue.insert("four");
              }
          }.start();

          new Thread() {
              public void run() {
                  System.out.println("Thread1: attempting to remove an item from the queue ");
                  Object o = blockerQueue.remove();
              }
          }.start();
      }
  }

  //This test code prints the following:
  //In insert(): inserted the element one
  //In insert(): notified that queue is not empty
  //In insert(): inserted the element two
  //In insert(): notified that queue is not empty
  //In insert(): inserted the element three
  //In insert(): notified that queue is not empty
  //Thread2: attempting to insert an item to the queue
  //In insert(): queue is full, so waiting for removal
  //Thread1: attempting to remove an item from the queue
  //In remove(): removed the element three
  //In remove(): signalled that there is space for insertion
  //In insert(): got notification that remove got called, so proceeding to insert the element
  //In insert(): inserted the element four In insert(): notified that queue is not empty

#+END_SRC

*** Wait/notify
Both methods can only be called after acquiring the relevant lock

notifyAll() awakens all threads waiting on a lock, it should be called almost always instead of notify()

#+BEGIN_SRC java
  class CoffeeMachine extends Thread {
      static String coffeeMade = null;
      static final Object lock = new Object();
      private static int coffeeNumber = 1;
      void makeCoffee() {
          synchronized(CoffeeMachine.lock) {
              if(coffeeMade ! = null) {

                  try {
                      System.out.println("Coffee machine: Waiting for waiter notification to deliver the coffee");
                      CoffeeMachine.lock.wait();
                  }
                  catch(InterruptedException ie) {
                      ie.printStackTrace();
                  }
              }
              coffeeMade = "Coffee No. " + coffeeNumber ++;
              System.out.println("Coffee machine says: Made " + coffeeMade);
              // once coffee is ready, notify the waiter to pick it up
              CoffeeMachine.lock.notifyAll();
              System.out.println("Coffee machine: Notifying waiter to pick the coffee ");
          }
      }

      public void run() {
          while(true) {
              makeCoffee();
              try {
                  System.out.println("Coffee machine: Making another coffee now");
                  // simulate the time taken to make a coffee by calling sleep method
                  Thread.sleep(10000);
              }
              catch(InterruptedException ie) {
                  // its okay to ignore this exception since we're not using thread interrupt mechanism
                  ie.printStackTrace();
              }
          }
      }
  }

  // The Waiter runs as an independent thread
  // It interacts with the CoffeeMachine to wait for a coffee
  // and deliver the coffee once ready and request the coffee machine
  // for the next one, and this activity keeps going on forever . . .
  class Waiter extends Thread {
      public void getCoffee() {
          synchronized(CoffeeMachine.lock) {
              if(CoffeeMachine.coffeeMade == null) {
                  try {
                      // wait till the CoffeeMachine says (notifies) that coffee is ready
                      System.out.println("Waiter: Will get orders till coffee machine notifies me ");
                      CoffeeMachine.lock.wait();
                  }
                  catch(InterruptedException ie) {
                      // its okay to ignore this exception since we're not using thread interrupt mechanism
                      ie.printStackTrace();
                  }
              }
              System.out.println("Waiter: Delivering " + CoffeeMachine.coffeeMade);
              CoffeeMachine.coffeeMade = null;
              // ask (notify) the coffee machine to prepare the next coffee
              CoffeeMachine.lock.notifyAll();
              System.out.println("Waiter: Notifying coffee machine to make another one");
          }
      }
      public void run() {
          // keep going till the user presses ctrl-C and terminates the program
          while(true) {
              getCoffee();
          }
      }
  }

#+END_SRC

*** Thread safety
- For each mutable state variable that may be accessed by more than one thread, all accesses to that variable must be  performed with the same lock held.
In this case, we say that the variable is guarded by that lock.

- Every shared, mutable variable should be guarded by exactly one lock. Make it clear to maintainers which lock that is.

- For every invariant that involves more than one variable, all the variables involved in that invariant must be guarded by  the same lock.

- Avoid holding locks during lengthy computations or operations at risk of not completing quickly such as network or  console I/O.

Example of unsynchronized code
#+BEGIN_SRC java
  public class NoVisibility {
      private static boolean ready;
      private static int number;
      private static class ReaderThread extends Thread {
          public void run() {
              while (!ready)
                  Thread.yield();
              System.out.println(number);
          }
      }
      public static void main(String[] args) {
          new ReaderThread().start();
          number = 42;
          ready = true;
      }
  }

#+END_SRC

- Locking is not just about mutual exclusion; it is also about memory visibility.
To ensure that all threads see the most up? to?date values of shared mutable variables, the reading and writing threads must synchronize on a common lock.

**** Volatile
The visibility effects of volatile variables extend beyond the value of the volatile variable itself.
When thread A writes to  a volatile variable and subsequently thread B reads that same variable,
the values of all variables that were visible to A  prior to writing to the volatile variable become visible to B after reading the volatile variable.
So from a memory visibility  perspective, writing a volatile variable is like exiting a synchronized block and reading a volatile variable is like entering  a synchronized block.
However, we do not recommend relying too heavily on volatile variables for visibility;
code that  relies on volatile variables for visibility of arbitrary state is more fragile and harder to understand than code that uses  locking.

- Use volatile variables only when they simplify implementing and verifying your synchronization policy;
avoid using  volatile variables when verifying correctness would require subtle reasoning about visibility.
Good uses of volatile  variables include ensuring the visibility of their own state, that of the object they refer to,
or indicating that an  important lifecycle event (such as initialization or shutdown) has occurred.

- Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.


*** Object Publication

To publish an object safely, both the reference to the object and the object's state must be made visible to other threads at the same time.
A properly constructed object can be safely published by:
- Initializing an object reference from a static initializer e.g. public static Holder holder = new Holder(42);
- Storing a reference to it into a volatile field or AtomicReference;
- Storing a reference to it into a final field of a properly constructed object; or  Storing a reference to it into a field that is properly guarded by a lock.
If a state variable is thread?safe, does not participate in any invariants that constrain its value,
and has no prohibited  state transitions for any of its operations, then it can safely be published.


**** Thread safe Collections
Placing a key or value in a Hashtable, synchronizedMap, or Concurrent-Map safely publishes it to any thread that retrieves it from the Map (whether directly or via an iterator);
- Placing an element in a Vector, CopyOnWriteArrayList, CopyOnWrite-ArraySet, synchronizedList, or synchronizedSet safely publishes it to any thread that retrieves it from the collection;
- Placing an element on a BlockingQueue or a ConcurrentLinkedQueue safely publishes it to any thread that retrieves it from the queue.

ConcurrentHashMap is more efficient than synchronized collections but does not allow exclusive locking, instead uses lock striping.


**** Confinement
Do not allow the this reference to escape during construction.

Can be done via using a factory method which ensures object is fully initialized before making a reference visible.
#+BEGIN_SRC java
public class SafeListener {
    private final EventListener listener;
    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
} };
}
    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
#+END_SRC

***** Stack confinement
Any local primitive types in a thread function are automatically thread safe

***** ThreadLocal
A more formal means of maintaining thread confinement is ThreadLocal, which allows you to associate a per thread  value with a value holding object.
Thread-Local provides get and set accessor methods that maintain a separate copy of the value for each thread that uses it,
so a get returns the most recent value passed to set from the currently executing thread.

Useful for applications which use mutable singletons e.g. J2EE containers use a threadlocal transaction context for the duration for a EJB call.
#+BEGIN_SRC java
private static ThreadLocal<Connection> connectionHolder
    = new ThreadLocal<Connection>() {
        public Connection initialValue() {
            return DriverManager.getConnection(DB_URL);
        }
};
public static Connection getConnection() {
    return connectionHolder.get();
}
#+END_SRC


**** Common policies for sharing objects
Thread confined: A thread confined object is owned exclusively by and confined to one thread, and can be modified by its owning thread.
Shared read only: A shared read only object can be accessed concurrently by multiple threads without additional synchronization, but cannot be modified by any thread. Shared read only objects include immutable and effectively immutable objects.
Shared thread safe: A thread safe object performs synchronization internally, so multiple threads can freely access it through its public interface without further synchronization.
Guarded: A guarded object can be accessed only with a specific lock held. Guarded objects include those that are encapsulated within other thread safe objects and published objects that are known to be guarded by a specific lock.



*** Object composition
You cannot ensure thread safety without understanding an object's invariants and post conditions.
Constraints on the valid values or state transitions for state variables can create atomicity and encapsulation requirements.

Just as encapsulating an object's state makes it easier to preserve its invariants,
encapsulating its synchronization makes  it easier to enforce its synchronization policy.

**** Delegation
Use thread safe datastructures to perform concurrent operations.

If a class is composed of multiple independent thread?safe state variables and has no operations that have any invalid  state transitions,
then it can delegate thread safety to the underlying state variables.

e.g.
#+BEGIN_SRC java
  public class DelegatingVehicleTracker {
       private final ConcurrentMap<String, Point> locations;
       private final Map<String, Point> unmodifiableMap;

      public DelegatingVehicleTracker(Map<String, Point> points) {
           locations = new ConcurrentHashMap<String, Point>(points);
           unmodifiableMap = Collections.unmodifiableMap(locations);
       }
      public Map<String, Point> getLocations() {
           return unmodifiableMap;
       }
      public Point getLocation(String id) {
           return locations.get(id);
       }
      public void setLocation(String id, int x, int y) {
           if (locations.replace(id, new Point(x, y)) == null)
               throw new IllegalArgumentException("invalid vehicle name: " + id);
       }
  }

    @Immutable public class Point {
        public final int x, y;
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
#+END_SRC


**** Java Monitor Pattern
All object state is encapsulated and all accessors/mutators are synchronized
e.g.
#+BEGIN_SRC java
  public class MonitorVehicleTracker {
      @GuardedBy("this")
      private final Map<String, MutablePoint> locations;
      public MonitorVehicleTracker(Map<String, MutablePoint> locations) {
          this.locations = deepCopy(locations);
      }
      public synchronized Map<String, MutablePoint> getLocations() {
          return deepCopy(locations);
      }
      public synchronized  MutablePoint getLocation(String id) {
          MutablePoint loc = locations.get(id);
          return loc == null ? null : new MutablePoint(loc);
      }
      public synchronized  void setLocation(String id, int x, int y) {
          MutablePoint loc = locations.get(id);
          if (loc == null)
              throw new IllegalArgumentException("No such ID: " + id);
          loc.x = x;
          loc.y = y;
      }
      private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
          Map<String, MutablePoint> result = new HashMap<String, MutablePoint>();
          for (String id : m.keySet())
              result.put(id, new MutablePoint(m.get(id)));
          return Collections.unmodifiableMap(result);
      }
  }

  @NotThreadSafe public class MutablePoint {
      public int x, y;
      public MutablePoint() {
          x = 0; y = 0;
      }
      public MutablePoint(MutablePoint p) {
          this.x = p.x;
          this.y = p.y;
      }
  }

#+END_SRC




*** Blocking Queues
Use the producer consumer Pattern
e.g. File crawler (Producer) Indexer(Consumer)

#+BEGIN_SRC java
  public class FileCrawler implements Runnable {
      private final BlockingQueue<File> fileQueue;
      private final FileFilter fileFilter;
      private final File root;
      public void run() {
          try {
              crawl(root);
          }
          catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
      }

      private void crawl(File root) throws InterruptedException {
          File[] entries = root.listFiles(fileFilter);
          if (entries != null) {
              for (File entry : entries)
                  if (entry.isDirectory())
                      crawl(entry);
                  else if (!alreadyIndexed(entry))
                      fileQueue.put(entry);
          }
      }
  }

  public class Indexer implements Runnable {
      private final BlockingQueue<File> queue;

      public Indexer(BlockingQueue<File> queue) {
          this.queue = queue;
      }

      public void run() {
          try {
              while (true)
                  indexFile(queue.take());
          }
          catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
      }
  }

  public static void startIndexing(File[] roots) {
      BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
      FileFilter filter = new FileFilter() {
              public boolean accept(File file) {
                  return true;
              }
          }
          ;

      for (File root : roots)
          new Thread(new FileCrawler(queue, filter, root)).start();

      for (int i = 0;i < N_CONSUMERS;i++)
          new Thread(new Indexer(queue)).start();
  }

#+END_SRC

**** Deques and BlockingDeques
Variant of blocking queue which allows insertion, removal from head and tail position.

***** Work-stealing Pattern
Each consumer has its own deque and when exhausts it, it reads from the tail end of another consumer's deque

Work stealing is well suited to problems in which consumers are also producers
when performing a unit of work is  likely to result in the identification of more work.
For example, processing a page in a web crawler usually results in the  identification of new pages to be crawled.
Similarly, many graph?exploring algorithms, such as marking the heap during  garbage collection, can be efficiently parallelized using work stealing.




*** Synchronizers
Any object which controls flow of execution to threads based on its state. e.g. blocking queue

**** Latch
Allows notification of threads from an outside agent
A synchronizer which blocks execution until a set of conditions have been satisfied, it cannot be reverted to an earlier state e.g. CountDownLatch, FutureTask

example using CountDownLatch

| CountDownLatch(int count)                  | Creates an instance of CountDownLatch with the number of times the countDown() method must be called before the threads waiting with await() can continue execution.                                                                     |
| void await()                               | If the current count in CountDownLatch object is zero, it immediately returns; otherwise, the thread blocks until the countdown reaches zero. Can throw an InterruptedException.                                                         |
| boolean await(long timeout, TimeUnit unit) | Same as the previous method, await(), but takes an additional time-out argument. If the thread returns successfully after the count reaches zero, this method returns true; if the thread returns because of time-out, it returns false. |
| void countDown()                           | Reduces the number of counts by one in this CountDownLatch object. If the count reaches zero, all the (a)waiting threads are released. If the current count is already zero, nothing happens.                                            |
| long getCount()                            | Returns the pending counts in this CountDownLatch object.                                                                                                                                                                                |

#+BEGIN_SRC java
  public class TestHarness {
      public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
          final CountDownLatch startGate = new CountDownLatch(1);
          final CountDownLatch endGate = new CountDownLatch(nThreads);

          for (int i = 0;i < nThreads;i++) {
              Thread t = new Thread() {
                      public void run() {
                          try {
                              startGate.await();
                              try {
                                  task.run();
                              }
                              finally {
                                  endGate.countDown();
                              }
                          }
                          catch (InterruptedException ignored) {
                          }
                      }
                  };
              t.start();
          }

          long start = System.nanoTime();
          startGate.countDown();
          endGate.await();
          long end = System.nanoTime();
          return end-start;
      }
  }


#+END_SRC

example using FutureTask
#+BEGIN_SRC java
  public class Preloader {
      private final FutureTask<ProductInfo> future = new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
              public ProductInfo call() throws DataLoadException {
                  return loadProductInfo();
              }
          });

      private final Thread thread = new Thread(future);

      public void start() {
          thread.start();
      }

      public ProductInfo get() throws DataLoadException, InterruptedException {
          try {
              return future.get();
          }
          catch (ExecutionException e) {
              Throwable cause = e.getCause();
              if (cause instanceof DataLoadException)
                  throw (DataLoadException) cause;
              else
                  throw launderThrowable(cause);
          }
      }
  }


#+END_SRC


**** Semaphores
Counting useful for controlling allocation and retrieval of a finite number of resources e.g. database connections

| Semaphore(int permits)                                               | Constructor to create Semaphore objects with a given number of permits (the number of threads that can access the resource at a time). If the permit’s value is negative, the given number of release() calls must happen before acquire() calls can succeed.                                                                  |
| Semaphore(int permits, boolean fair)                                 | Same as the previous constructor, but this extra fair option indicates that the permits should be allotted on a first-come-first-served basis.                                                                                                                                                                                    |
| void acquire() void acquire(int permits)                             | Acquires a permit if available; otherwise, it blocks until a permit becomes available. Can throw an InterruptedException if some other thread interrupts it while waiting to acquire a permit. The overloaded version takes a number of permits as an argument.                                                                   |
| void  acquireUninterruptibly()                                       | Same as the acquire() method, but this thread cannot be interrupted while waiting to acquire a permit.                                                                                                                                                                                                                            |
| boolean tryAcquire() boolean tryAcquire(long timeout, TimeUnit unit) | Acquires a permit from the semaphore if available at the time of the call and returns true; if unavailable, it returns false immediately (without blocking). The overloaded tryAcquire() method additionally takes a time-out argument—the thread blocks to acquire a permit from the semaphore until a given time-out period. |
| void release() void release(int permits)                             | Releases a permit from the semaphore. The overloaded version specifies the number of permits to release.                                                                                                                                                                                                                          |

#+BEGIN_SRC java
  import java.util.concurrent.Semaphore;
  // This class simulates a situation where an ATM room has only two ATM machines
  // and five people are waiting to access the machine. Since only one person can access
  // an ATM machine at a given time, others wait for their turn
  class ATMRoom {
      public static void main(String []args) {
          // assume that only two ATM machines are available in the ATM room
          Semaphore machines = new Semaphore(2);
          // list of people waiting to access the machine
          new Person(machines, "Mickey");
          new Person(machines, "Donald");
          new Person(machines, "Tom");
          new Person(machines, "Jerry");
          new Person(machines, "Casper");
      }
  }

  // Each Person is an independent thread;but their access to the common resource
  // (two ATM machines in the ATM machine room in this case) needs to be synchronized.
  class Person extends Thread {
      private Semaphore machines;
      public Person(Semaphore machines, String name) {
          this.machines = machines;
          this.setName(name);
          this.start();
      }
      public void run() {
          try {
              System.out.println(getName() + " waiting to access an ATM machine");
              machines.acquire();
              System.out.println(getName() + " is accessing an ATM machine");
              Thread.sleep(1000);
              // simulate the time required for withdrawing amount
              System.out.println(getName() + " is done using the ATM machine");
              machines.release();
          }
          catch(InterruptedException ie) {
              System.err.println(ie);
          }
      }
  }


#+END_SRC


****  Exchanger
Small class used to transfer information between threads

#+BEGIN_SRC java
  import java.util.concurrent.Exchanger;

  // The DukeThread class runs as an independent thread. It talks to the CoffeeShopThread that
  // also runs independently. The chat is achieved by exchanging messages through a common
  // Exchanger<String> object that synchronizes the chat between them.
  // Note that the message printed are the "responses" received from CoffeeShopThread
  class DukeThread extends Thread {
      private Exchanger<String> sillyTalk;
      public DukeThread(Exchanger<String> args) {
          sillyTalk = args;
      }
      public void run() {
          String reply = null;
          try {
              // start the conversation with CoffeeShopThread
              reply = sillyTalk.exchange("Knock knock!");
              // Now, print the response received from CoffeeShopThread
              System.out.println("CoffeeShop: " + reply);
              // exchange another set of messages
              reply = sillyTalk.exchange("Duke");
              // Now, print the response received from CoffeeShopThread
              System.out.println("CoffeeShop: " + reply);

              // an exchange could happen only when both send and receive happens
              // since this is the last sentence to speak, we close the chat by ignoring the "dummy" reply
              reply = sillyTalk.exchange("The one who was born in this coffee shop!");
              // talk over, so ignore the reply!                }
              catch(InterruptedException ie) {
                  System.err.println("Got interrupted during my silly talk");
              }
          }
      }

      class CoffeeShopThread extends Thread {
          private Exchanger<String> sillyTalk;
          public CoffeeShopThread(Exchanger<String> args) {
              sillyTalk = args;
          }
          public void run() {
              String reply = null;
              try {
                  // exchange the first messages
                  reply = sillyTalk.exchange("Who's there?");
                  // print what Duke said
                  System.out.println("Duke: " + reply);
                  // exchange second message
                  reply = sillyTalk.exchange("Duke who?");
                  // print what Duke said
                  System.out.println("Duke: " + reply);
                  // there is no message to send, but to get a message from Duke thread, both ends should send a message; so send a "dummy" string
                  reply = sillyTalk.exchange("");
                  System.out.println("Duke: " + reply);
              }
              catch(InterruptedException ie) {
                  System.err.println("Got interrupted during my silly talk");
              }
          }
      }

      // Coordinate the silly talk between Duke and CoffeeShop by instantitaing the Exchanger object // and the CoffeeShop and Duke threads
      class KnockKnock {
          public static void main(String []args) {
              Exchanger<String> sillyTalk = new Exchanger<String>();
              new CoffeeShopThread(sillyTalk).start();
              new DukeThread(sillyTalk).start();
          }
      }

      //The program prints the following:
      //Duke: Knock knock! CoffeeShop: Who's there? Duke: Duke CoffeeShop: Duke who? Duke: The one who was born in this coffee shop!

#+END_SRC



**** Barriers
Allows automatic notification to threads that they can start
Synchronizers which block execution until all threads are ready. e.g. CyclicBarrier

| CyclicBarrier(int numThreads)                      | Creates a CyclicBarrier object with the number of threads waiting on it specified. Throws IllegalArgumentException if numThreads is negative or zero.                                                                                                                                                                                                                                                                                                                                                                                                                           |
| CyclicBarrier(int parties, Runnable barrierAction) | Same as the previous constructor; this constructor additionally takes the thread to call when the barrier is reached.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| int await() int await(long timeout, TimeUnit unit) | Blocks until the specified number of threads have called await() on this barrier. The method returns the arrival index of this thread. This method can throw an InterruptedException if the thread is interrupted while waiting for other threads or a BrokenBarrierException if the barrier was broken for some reason (for example, another thread was timed-out or interrupted). The overloaded method takes a time-out period as an additional option; this overloaded version throws a TimeoutException if all other threads aren’t reached within the time-out period. |
| boolean isBroken()                                 | Returns true if the barrier is broken. A barrier is broken if at least one thread in that barrier was interrupted or timed-out, or if a barrier action failed throwing an exception.                                                                                                                                                                                                                                                                                                                                                                                            |
| void reset()                                       | Resets the barrier to the initial state. If there are any threads waiting on that barrier, they will throw the BrokenBarrier exception.                                                                                                                                                                                                                                                                                                                                                                                                                                         |

#+BEGIN_SRC java
  import java.util.concurrent.*;

  // The run() method in this thread should be called only when four players are ready to start the game
  class MixedDoubleTennisGame extends Thread {
      public void run() {
          System.out.println("All four players ready, game starts \n Love all...");
      }
  }

  // This thread simulates arrival of a player. // Once a player arrives, he/she should wait for other players to arrive
  class Player extends Thread {
      CyclicBarrier waitPoint;
      public Player(CyclicBarrier barrier, String name) {
          this.setName(name);
          waitPoint = barrier;
          this.start();
      }
      public void run() {
          System.out.println("Player " + getName() + " is ready ");

          try {
              waitPoint.await();
              // await for all four players to arrive
          }
          catch(BrokenBarrierException | InterruptedException exception) {
              System.out.println("An exception occurred while waiting... " + exception);
          }
      }
  }

  // Creates a CyclicBarrier object by passing the number of threads and the thread to run // when all the threads reach the barrier
  class CyclicBarrierTest {
      public static void main(String []args) {
          // a mixed-double tennis game requires four players;so wait for four players (i.e., four threads) to join to start the game
          System.out.println("Reserving tennis court \n As soon as four players arrive,  game will start");
          CyclicBarrier barrier = new CyclicBarrier(4, new MixedDoubleTennisGame());
          new Player(barrier, "G I Joe");
          new Player(barrier, "Dora");
          new Player(barrier, "Tintin");
          new Player(barrier, "Barbie");
      }
  }

  //The program prints the following:
  //Reserving tennis court As soon as four players arrive, game will start
  //Player G I Joe is ready
  //Player Dora is ready
  //Player Tintin is ready
  //Player Barbie is ready
  //All four players ready, game starts
  //Love all...


#+END_SRC

#+BEGIN_SRC java
  public class CellularAutomata {
      private final Board mainBoard;
      private final CyclicBarrier barrier;
      private final Worker[] workers;

      public CellularAutomata(Board board) {
          this.mainBoard = board;
          int count = Runtime.getRuntime().availableProcessors();
          this.barrier = new CyclicBarrier(count, new Runnable() {
                  public void run() {
                      mainBoard.commitNewValues();
                  }
              });
          this.workers = new Worker[count];
          for (int i = 0;i < count;i++)
              workers[i] = new Worker(mainBoard.getSubBoard(count, i));
      }

      private class Worker implements Runnable {
          private final Board board;

          public Worker(Board board) {
              this.board = board;
          }
          public void run() {
              while (!board.hasConverged()) {
                  for (int x = 0;x < board.getMaxX();x++)
                      for (int y = 0;y < board.getMaxY();y++)
                          board.setNewValue(x, y, computeValue(x, y));
                  try {
                      barrier.await();
                  }
                  catch (InterruptedException ex) {
                      return;
                  }
                  catch (BrokenBarrierException ex) {
                      return;
                  }
              }
          }
      }

      public void start() {
          for (int i = 0;
               i < workers.length;
               i++)             new Thread(workers[i]).start();
          mainBoard.waitForConvergence();
      }
  }

#+END_SRC



**** Phaser
Used to setup sync points for threads during execution of a task.
Useful for parallel batch processing?

| Phaser()                         | Creates a Phaser object with no registered parties and no parents. The initial phase is set to 0.                                                                                  |
| Phaser(int numThreads)           | Creates a Phaser object with a given number of threads (parties) to arrive to advance to the next stage; the initial phase is set to 0.                                            |
| int register()                   | Adds a new thread (party) to this Phaser object. Returns the phase current number. Throws an IllegalStateException if the maximum supported parties are already registered.        |
| int bulkRegister(int numThreads) | Adds numThreads of unarrived parties to this Phaser object. Returns the phase current number. Throws an IllegalStateException if maximum supported parties are already registered. |
| int arrive()                     | Arrives at this phase without waiting for other threads to arrive. Returns the arrival phase number. Can throw an IllegalStateException.                                           |
| int arriveAndDeregister()        | Same as the previous method, but also deregisters from the Phaser object.                                                                                                          |
| int arriveAndAwaitAdvance()      | Arrive at this phase and waits (i.e., blocks) until other threads arrive.                                                                                                          |
| int awaitAdvance(int phase)      | Waits (i.e., blocks) until this Phaser object advances to the given  phase value.                                                                                                  |
| int getRegisteredParties()       | Returns the number of threads (parties) registered with this Phaser object.                                                                                                        |
| int getArrivedParties()          | Returns the number of threads (parties) arrived at the current phase of the Phaser object.                                                                                         |
| int getUnarrivedParties()        | Returns the number of threads (parties) that have not arrived when compared to the registered parties at the current phase of the Phaser object.                                   |

#+BEGIN_SRC java
  import java.util.concurrent.*;

  // ProcessOrder thread is the master thread overlooking to make sure that the Cook, Helper,
  // and Attendant are doing their part of the work to complete preparing the food items
  // and complete order delivery
  // To simplify the logic, we assume that each delivery order consists of exactly three food items
  class ProcessOrder {
      public static void main(String []args) throws InterruptedException {
          // the Phaser is the synchronizer to make food items one-by-one,
          // and deliver it before moving to the next item
          Phaser deliveryOrder = new Phaser(1);
          System.out.println("Starting to process the delivery order ");
          new Worker(deliveryOrder, "Cook");
          new Worker(deliveryOrder, "Helper");
          new Worker(deliveryOrder, "Attendant");
          for(int i = 1; i <= 3; i++) {
              // Prepare, mix and deliver this food item
              deliveryOrder.arriveAndAwaitAdvance();
              System.out.println("Deliver food item no. " + i);
          }
          // work completed for this delivery order, so deregister
          deliveryOrder.arriveAndDeregister();
          System.out.println("Delivery order completed... give it to the customer");
      }
  }

  // The work could be a Cook, Helper, or Attendant. Though the three work independently, the
  // should all synchronize their work together to do their part and complete preparing a food item
  class Worker extends Thread {
      Phaser deliveryOrder;
      Worker(Phaser order, String name) {
          deliveryOrder = order;
          this.setName(name);
          deliveryOrder.register();
          start();
      }
      public void run() {
          for(int i = 1; i <= 3; i++) {
              System.out.println("\t" + getName() + " doing his work for order no. " + i);
              if(i == 3) {
                  // work completed for this delivery order, so deregister
                  deliveryOrder.arriveAndDeregister();
              }
              else {
                  deliveryOrder.arriveAndAwaitAdvance();
              }
              try {
                  Thread.sleep(3000);
                  // simulate time for preparing the food item                        }
                  catch(InterruptedException ie) {
                      /* ignore exception */
                      ie.printStackTrace();
                  }
              }
          }
      }
  }


#+END_SRC


*** Case study building a caching class
Needs minimum blocking
If a value is in the process of being computed but hasn't been cached yet then any other thread seeking the result should wait for the computation rather than start its own.

#+BEGIN_SRC java
  public interface Computable<A, V> {
      V compute(A arg) throws InterruptedException;
  }

  public class Memorizer<A, V> implements Computable<A, V> {
      private final ConcurrentMap<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
      private final Computable<A, V> c;
      public Memorizer(Computable<A, V> c) { this.c = c; }
      public V compute(final A arg) throws InterruptedException {
          while (true) {
              Future<V> f = cache.get(arg);
              if (f == null) {
                  Callable<V> eval = new Callable<V>() {
                      public V call() throws InterruptedException {
                          return c.compute(arg);
                      }
                  };
                  FutureTask<V> ft = new FutureTask<V>(eval);
                  f = cache.putIfAbsent(arg, ft);
                  if (f == null) {
                      f = ft;
                      ft.run();
                  }
              }
              try {
                  return f.get();
              }
              catch (CancellationException e) {
                  cache.remove(arg, f);
              }
              catch (ExecutionException e) {
                  throw launderThrowable(e.getCause());
              }
          }
      }
  }
  public class Factorizer implements Servlet {
      private final Computable<BigInteger, BigInteger[]> c = new Computable<BigInteger, BigInteger[]>() {
          public BigInteger[] compute(BigInteger arg) {
              return factor(arg);
          }
      };
      private final Computable<BigInteger, BigInteger[]> cache         = new Memorizer<BigInteger, BigInteger[]>(c);

      public void service(ServletRequest req, ServletResponse resp) {
          try {
              BigInteger i = extractFromRequest(req);
              encodeIntoResponse(resp, cache.compute(i));
          }
          catch (InterruptedException e) {
              encodeError(resp, "factorization interrupted");
          }
      }
  }


#+END_SRC


*** Executor framework

                       Executor (Interface)
                                |
                       ExecutorService (Interface)
                                |
                AbstractExecutorService (abstract class)
                         |              |
                ThreadPoolExecutor ForkJoinPool
                         |
            ScheduledThreadPoolExecutor

#+BEGIN_SRC java
  public interface Executor {
      void execute(Runnable command);
  }

  class TaskExecutionWebServer {
      private static final int NTHREADS = 100;
      private static final Executor exec         = Executors.newFixedThreadPool(NTHREADS);

      public static void main(String[] args) throws IOException {
          ServerSocket socket = new ServerSocket(80);
          while (true) {
              final Socket connection = socket.accept();
              Runnable task = new Runnable() {
                      public void run() {
                          handleRequest(connection);
                      }             };
              exec.execute(task);
          }
      }
  }

#+END_SRC

**** ExecutorService
public interface ExecutorService extends Executor {
     void shutdown();
     List<Runnable> shutdownNow();
     boolean isShutdown();
     boolean isTerminated();
     boolean awaitTermination(long timeout, TimeUnit unit)         throws InterruptedException;
     //  ... additional convenience methods for task submission
}


Timer is bad because it creates a single thread for all timed tasks and doesn't handle any unchecked exceptions. Use ScheduledThreadPoolExecutor instead.


**** Future

#+BEGIN_SRC java
  public interface Callable<V> {
      V call() throws Exception;
  }
  public interface Future<V> {
      boolean cancel(boolean mayInterruptIfRunning);
      boolean isCancelled();
      boolean isDone();
      V get() throws InterruptedException, ExecutionException, CancellationException;
      V get(long timeout, TimeUnit unit)  throws InterruptedException, ExecutionException, CancellationException, TimeoutException;
  }


#+END_SRC
Future represents the lifecycle of a task and provides methods to test whether the task has completed or been  cancelled, retrieve its result, and cancel the task.
Callable and  Future are shown in Listing 6.11. Implicit in the  specification of Future is that task lifecycle can only move forwards,
not backwards ? just like the ExecutorService  lifecycle. Once a task is completed, it stays in that state forever.

The behavior of get varies depending on the task state (not yet started, running, completed).
It returns immediately or  throws an  Exception if the task has already completed, but if not it blocks until the task completes.
If the task  completes by throwing an exception, get rethrows it wrapped in an ExecutionException; if it was cancelled, get  throws CancellationException.
If get throws ExecutionException, the underlying exception can be retrieved with  getCause.

Calling get() with timeout limit will throw a TimeoutException, it can be caught and the future can be cancelled


**** CompletionService
Allows easier retrieval of results of Futures as they become available.

Maintains a BlockingQueue of QueueingFutures which can be queried using take(), poll()
#+BEGIN_SRC java
  private class QueueingFuture<V> extends FutureTask<V> {
      QueueingFuture(Callable<V> c) {
          super(c);
      }
      QueueingFuture(Runnable t, V r) {
          super(t, r);
      }

      protected void done() {
          completionQueue.add(this);
      }
  }

#+END_SRC

Example Usage
#+BEGIN_SRC java
  public class Renderer {
      private final ExecutorService executor;

      Renderer(ExecutorService executor) {
          this.executor = executor;
      }

      void renderPage(CharSequence source) {
          final List<ImageInfo> info = scanForImageInfo(source);
          CompletionService<ImageData> completionService = new ExecutorCompletionService<ImageData>(executor);
          for (final ImageInfo imageInfo : info)
              completionService.submit(new Callable<ImageData>() {
                      public ImageData call() {
                          return imageInfo.downloadImage();
                      }
                  });

          renderText(source);

          try {
              for (int t = 0, n =  info.size();t < n;t++) {
                  Future<ImageData> f = completionService.take();
                  ImageData imageData = f.get();
                  renderImage(imageData);
              }
          }
          catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
          catch (ExecutionException e) {
              throw launderThrowable(e.getCause());
          }
      }
  }


#+END_SRC


*** Task Cancellation
Use isInterrupted() on a thread to check if the interrupted status has been set.

Whenever a InterruptedException is caught the interrupt status is reset. It should usually be set to true again by calling Thread.getCurrentThread().interrupt()

Bad idea to cancel thread if thread is not owned by the code cancelling it.

or Future.cancel()

Custom Cancellation

#+BEGIN_SRC java
  public interface CancellableTask<T> extends Callable<T> {
      void cancel();
      RunnableFuture<T> newTask();
  }

  @ThreadSafe
  public class CancellingExecutor extends ThreadPoolExecutor {
      ...
      protected<T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
          if (callable instanceof CancellableTask)
              return ((CancellableTask<T>) callable).newTask();
          else
              return super.newTaskFor(callable);
      }
  }

  public abstract class SocketUsingTask<T>         implements CancellableTask<T> {
      @GuardedBy("this") private Socket socket;

      protected synchronized void setSocket(Socket s) {
              socket = s;
          }

      public synchronized void cancel() {
              try {
                  if (socket != null)
                      socket.close();
              }
              catch (IOException ignored) {
              }
          }

      public RunnableFuture<T> newTask() {
          return new FutureTask<T>(this) {
              public boolean cancel(boolean mayInterruptIfRunning) {
                  try {
                      SocketUsingTask.this.cancel();
                  }
                  finally {
                      return super.cancel(mayInterruptIfRunning);
                  }
              }
          };
      }
  }


#+END_SRC

Logging Service with no shutdown support
#+BEGIN_SRC java
  public class LogWriter {
      private final BlockingQueue<String> queue;
      private final LoggerThread logger;

      public LogWriter(Writer writer) {
          this.queue = new LinkedBlockingQueue<String>(CAPACITY);
          this.logger = new LoggerThread(writer);
      }

      public void start() {
          logger.start();
      }

      public void log(String msg) throws InterruptedException {
          queue.put(msg);
      }

      private class LoggerThread extends Thread {
          private final PrintWriter writer;
          ...
              public void run() {
              try {
                  while (true)                    writer.println(queue.take());
              }
              catch(InterruptedException ignored) {
              }
              finally {
                  writer.close();
              }
          }
      }
  }


#+END_SRC

Logging with shutdown support
#+BEGIN_SRC java
  public class LogService {
      private final BlockingQueue<String> queue;
      private final LoggerThread loggerThread;
      private final PrintWriter writer;
      @GuardedBy("this") private boolean isShutdown;
      @GuardedBy("this") private int reservations;

      public void start() {
          loggerThread.start();
      }

      public void stop() {
          synchronized (this) {
              isShutdown = true;
          }
          loggerThread.interrupt();
      }

      public void log(String msg) throws InterruptedException {
          synchronized (this) {
              if (isShutdown)
                  throw new IllegalStateException(...);
              ++reservations;
          }
          queue.put(msg);
      }

      private class LoggerThread extends Thread {
          public void run() {
              try {
                  while (true) {
                      try {
                          synchronized (this) {
                              if (isShutdown && reservations == 0)
                                  break;
                          }
                          String msg = queue.take();
                          synchronized (this) {
                              --reservations;
                          }
                          writer.println(msg);
                      }
                      catch (InterruptedException e) {
                          /*  retry  */
                      }
                  }
              }
              finally {
                  writer.close();
              }
          }
      }
  }

#+END_SRC

Using ExecutorService
#+BEGIN_SRC java
  public class LogService {
      private final ExecutorService exec = newSingleThreadExecutor();
      ...
          public void start() {
          }

      public void stop() throws InterruptedException {
          try {
              exec.shutdown();
              exec.awaitTermination(TIMEOUT, UNIT);
          }
          finally {
              writer.close();
          }
      }
      public void log(String msg) {
          try {
              exec.execute(new WriteTask(msg));
          }
          catch (RejectedExecutionException ignored) {
          }
      }
  }


#+END_SRC

Resumable Executor
#+BEGIN_SRC java

    public class TrackingExecutor extends AbstractExecutorService {
        private final ExecutorService exec;
        private final Set<Runnable> tasksCancelledAtShutdown = Collections.synchronizedSet(new HashSet<Runnable>());
        ...
            public List<Runnable> getCancelledTasks() {
                if (!exec.isTerminated())
                    throw new IllegalStateException(...);
                return new ArrayList<Runnable>(tasksCancelledAtShutdown);
            }

        public void execute(final Runnable runnable) {
            exec.execute(new Runnable() {
                    public void run() {
                        try {
                            runnable.run();
                        }
                        finally {
                            if (isShutdown() && Thread.currentThread().isInterrupted())
                                tasksCancelledAtShutdown.add(runnable);
                        }
                    }
                }
                );
        }

        // delegate other ExecutorService methods to exec
        public abstract class WebCrawler {
            private volatile TrackingExecutor exec;
            @GuardedBy("this")     private final Set<URL> urlsToCrawl = new HashSet<URL>();
            ...
v                public synchronized void start() {
                    exec = new TrackingExecutor(Executors.newCachedThreadPool());
                    for (URL url : urlsToCrawl) submitCrawlTask(url);
                    urlsToCrawl.clear();
                }

            public synchronized void stop() throws InterruptedException {
                try {
                    saveUncrawled(exec.shutdownNow());
                    if (exec.awaitTermination(TIMEOUT, UNIT))
                        saveUncrawled(exec.getCancelledTasks());
                }
                finally {
                    exec = null;
                }
            }

            protected abstract List<URL> processPage(URL url);

            private void saveUncrawled(List<Runnable> uncrawled) {
                for (Runnable task : uncrawled)
                    urlsToCrawl.add(((CrawlTask) task).getPage());
            }
            private void submitCrawlTask(URL u) {
                exec.execute(new CrawlTask(u));
            }
            private class CrawlTask implements Runnable {
                private final URL url;
                ...
                    public void run() {
                        for (URL link : processPage(url)) {
                            if (Thread.currentThread().isInterrupted())
                                return;
                            submitCrawlTask(link);
                        }
                    }
                public URL getPage() {
                    return url;
                }
            }
        }


#+END_SRC

**** Handling uncaught exceptions from Threads
Thread.setDefaultUncaughtExceptionHandler()
public interface UncaughtExceptionHandler {     void uncaughtException(Thread t, Throwable e); }

**** JVM Shutdown hook
#+BEGIN_SRC java
  public void start() {
      Runtime.getRuntime().addShutdownHook(new Thread() {
              public void run() {
                  try {
                      LogService.this.stop();
                  }
                  catch (InterruptedException ignored) {
                  }
              }
          });
  }

#+END_SRC




*** Thread Pools
Optimum number of threads = number_of_cpus * cpu_usage (1> u >0) * wait_time/compute_time

newCachedThreadPool a good choice for a default executor
#+BEGIN_SRC java
  public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
      ...
  }


#+END_SRC

Bounded Queues good for independent tasks
Synchronous Queue: a mechanism to directly assign tasks to threads instead of maintaining a queue

**** Parallel Execution
Simple
#+BEGIN_SRC java
  public<T> void sequentialRecursive(List<Node<T>> nodes, Collection<T> results) {
      for (Node<T> n : nodes) {
          results.add(n.compute());
          sequentialRecursive(n.getChildren(), results);
      }
  }

  public<T> void parallelRecursive(final Executor exec, List<Node<T>> nodes, final Collection<T> results) {
      for (final Node<T> n : nodes) {
          exec.execute(new Runnable() {
                  public void run() {
                      results.add(n.compute());
                  }
              });
          parallelRecursive(exec, n.getChildren(), results);
      }
  }


#+END_SRC

Depth First Search

#+BEGIN_SRC java
    static class Node<P, M> {
        final P pos;
        final M move;
        final Node<P, M> prev;

        Node(P pos, M move, Node<P, M> prev) {
            ...}

        List<M> asMoveList() {
            List<M> solution = new LinkedList<M>();
            for (Node<P, M> n = this;n.move != null;n = n.prev)
                solution.add(0, n.move);
            return solution;
        }
    }


    public class SequentialPuzzleSolver<P, M> {
        private final Puzzle<P, M> puzzle;
        private final Set<P> seen = new HashSet<P>();

        public SequentialPuzzleSolver(Puzzle<P, M> puzzle) {
            this.puzzle = puzzle;
        }

        public List<M> solve() {
            P pos = puzzle.initialPosition();
            return search(new Node<P, M>(pos, null, null));
        }

        private List<M> search(Node<P, M> node) {
            if (!seen.contains(node.pos)) {
                seen.add(node.pos);
                if (puzzle.isGoal(node.pos))
                    return node.asMoveList();
                for (M move : puzzle.legalMoves(node.pos)) {
                    P pos = puzzle.move(node.pos, move);
                    Node<P, M> child = new Node<P, M>(pos, move, node);
                    List<M> result = search(child);
                    if (result != null)
                        return result;
                }
            }
            return null;
        }

    }

    public class ConcurrentPuzzleSolver<P, M> {
        private final Puzzle<P, M> puzzle;
        private final ExecutorService exec;
        private final ConcurrentMap<P, Boolean> seen;
        final ValueLatch<Node<P, M>> solution             = new ValueLatch<Node<P, M>>();
        ...
            public List<M> solve() throws InterruptedException {
                try {
                    P p = puzzle.initialPosition();
                    exec.execute(newTask(p, null, null));
                    // block until solution found
                    Node<P, M> solnNode = solution.getValue();
                    return (solnNode == null) ? null : solnNode.asMoveList();
                }
                finally {
                    exec.shutdown();
                }
            }

            protected Runnable newTask(P p, M m, Node<P,M> n) {
                return new SolverTask(p, m, n);
            }

            class SolverTask extends Node<P, M> implements Runnable {
                ...         public void run() {
                    if (solution.isSet() || seen.putIfAbsent(pos, true) != null)
                        return;
                    // already solved or seen this position
                    if (puzzle.isGoal(pos))
                        solution.setValue(this);
                    else
                        for (M m : puzzle.legalMoves(pos))
                            exec.execute(newTask(puzzle.move(pos, m), m, this));
                }
            }
    }

  @ThreadSafe public class ValueLatch<T> {
      @GuardedBy("this") private T value = null;
      private final CountDownLatch done = new CountDownLatch(1);

      public boolean isSet() {
          return (done.getCount() == 0);
      }
      public synchronized void setValue(T newValue) {
              if (!isSet()) {
                  value = newValue;
                  done.countDown();
              }
          }

      public T getValue() throws InterruptedException {
          done.await();
          synchronized (this) {
              return value;
          }
       }
  }

#+END_SRC

**** Saturation Policy
Several policies are available for RejectedExecutionHandler when a task is rejected
e.g. AbortPolicy, CallerRunsPolicy, DiscardPolicy, and DiscardOldestPolicy
#+BEGIN_SRC java
  ThreadPoolExecutor executor     = new ThreadPoolExecutor(N_THREADS,
                                                           N_THREADS,
                                                           0L,
                                                           TimeUnit.MILLISECONDS,
                                                           new LinkedBlockingQueue<Runnable>(CAPACITY));
  executor.setRejectedExecutionHandler(     new ThreadPoolExecutor.CallerRunsPolicy());

#+END_SRC


**** ThreadFactory
#+BEGIN_SRC java
  public class MyThreadFactory implements ThreadFactory {
      private final String poolName;

      public MyThreadFactory(String poolName) {
          this.poolName = poolName;
      }

      public Thread newThread(Runnable runnable) {
          return new MyAppThread(runnable, poolName);
      }
  }

  public class MyAppThread extends Thread {
      public static final String DEFAULT_NAME = "MyAppThread";
      private static volatile boolean debugLifecycle = false;
      private static final AtomicInteger created = new AtomicInteger();
      private static final AtomicInteger alive = new AtomicInteger();
      private static final Logger log = Logger.getAnonymousLogger();

      public MyAppThread(Runnable r) {
          this(r, DEFAULT_NAME);
      }

      public MyAppThread(Runnable runnable, String name) {
          super(runnable, name + "-" + created.incrementAndGet());
          setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
                  public void uncaughtException(Thread t, Throwable e) {
                      log.log(Level.SEVERE, "UNCAUGHT in thread " + t.getName(), e);
                  }
              });
      }

      public void run() {
          // Copy debug flag to ensure consistent value throughout.
          boolean debug = debugLifecycle;
          if (debug)
              log.log(Level.FINE, "Created "+getName());
          try {
              alive.incrementAndGet();
              super.run();
          }
          finally {
              alive.decrementAndGet();
              if (debug) log.log(Level.FINE, "Exiting "+getName());
          }
      }

      public static int getThreadsCreated() {
          return created.get();
      }
      public static int getThreadsAlive() {
          return alive.get();
      }
      public static boolean getDebug() {
          return debugLifecycle;
      }
      public static void setDebug(boolean b) {
          debugLifecycle = b;
      }
  }

#+END_SRC


**** Hooks
overridebeforeExecute, afterExecute, and terminated

#+BEGIN_SRC java
  public class TimingThreadPool extends ThreadPoolExecutor {
      private final ThreadLocal<Long> startTime = new ThreadLocal<Long>();
      private final Logger log = Logger.getLogger("TimingThreadPool");
      private final AtomicLong numTasks = new AtomicLong();
      private final AtomicLong totalTime = new AtomicLong();

      protected void beforeExecute(Thread t, Runnable r) {
          super.beforeExecute(t, r);
          log.fine(String.format("Thread %s: start %s", t, r));
          startTime.set(System.nanoTime());
      }

      protected void afterExecute(Runnable r, Throwable t) {
          try {
              long endTime = System.nanoTime();
              long taskTime = endTime - startTime.get();
              numTasks.incrementAndGet();
              totalTime.addAndGet(taskTime);
              log.fine(String.format("Thread %s: end %s, time=%dns", t, r, taskTime));
          }
          finally {
              super.afterExecute(r, t);
          }
      }

      protected void terminated() {
          try {
              log.info(String.format("Terminated: avg time=%dns", totalTime.get() / numTasks.get()));
          }
          finally {
              super.terminated();
          }
      }
  }


#+END_SRC



*** GUI
Swing is single threaded, all components, models are confined in the event thread and cannot be accessed out of it.

Acts somewhat like a single threaded executor

Methods callable from outside the event thread
SwingUtilities.isEventDispatchThread, which determines whether the current thread is the event thread;
SwingUtilities.invokeLater, which schedules a Runnable for execution on the event thread (callable from  any thread);
x SwingUtilities.invokeAndWait, which schedules a  Runnable task for execution on the event thread and  blocks the current thread until it completes (callable only from a non?GUI thread);
x methods to enqueue a repaint or revalidation request on the event queue (callable from any thread); and
x methods for adding and removing listeners (can be called from any thread, but listeners will always be invoked  in the event thread).

Simple Example of cancelling tasks through action listeners
#+BEGIN_SRC java
  Future<?>  runningTask = null;
  // thread-confined ...
  startButton.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {
              if (runningTask != null) {
                  runningTask = backgroundExec.submit(new Runnable() {
                          public void run() {
                              while (moreWork()) {
                                  if (Thread.currentThread().isInterrupted()) {
                                      cleanUpPartialWork();
                                      break;
                                  }
                                  doSomeWork();
                              }
                          }
                      });
              };
          }
      });

  cancelButton.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent event) {
              if (runningTask != null)
                  runningTask.cancel(true);
          }
      });


#+END_SRC

Background task supporting cancellation, completion, progress notification
#+BEGIN_SRC java
  abstract class BackgroundTask<V> implements Runnable, Future<V> {
      private final FutureTask<V> computation = new Computation();

      private class Computation extends FutureTask<V> {
          public Computation() {
              super(new Callable<V>() {
                      public V call() throws Exception {
                          return BackgroundTask.this.compute() ;
                      }
                  });
          }
          protected final void done() {
              GuiExecutor.instance().execute(new Runnable() {
                      public void run() {
                          V value = null;
                          Throwable thrown = null;
                          boolean cancelled = false;
                          try {
                              value = get();
                          }
                          catch (ExecutionException e) {
                              thrown = e.getCause();
                          }
                          catch (CancellationException e) {
                              cancelled = true;
                          }
                          catch (InterruptedException consumed) {
                          }
                          finally {
                              onCompletion(value, thrown, cancelled);
                          }
                      };
                  });
          }
      }
      protected void setProgress(final int current, final int max) {
          GuiExecutor.instance().execute(new Runnable() {
                  public void run() {
                      onProgress(current, max);
                  }
              });
      }
      // Called in the background thread
      protected abstract V compute()  throws Exception;
      // Called in the event thread
      protected void onCompletion(V result, Throwable exception,                                      boolean cancelled)  {
      }
      protected void  onProgress(int current, int max)  {
      }
      // Other Future methods forwarded to computation }

      public void runInBackground(final Runnable task) {
          startButton.addActionListener(new ActionListener() {
                  public void actionPerformed(ActionEvent e) {
                      class CancelListener implements ActionListener {
                          BackgroundTask<?> task;
                          public void actionPerformed(ActionEvent event) {
                              if (task != null)
                                  task.cancel(true);
                          }
                      }
                      final CancelListener listener = new CancelListener();
                      listener.task = new BackgroundTask<Void>() {
                          public Void compute() {
                              while (moreWork() && !isCancelled())
                                  doSomeWork();
                              return null;
                          }

                          public void onCompletion(boolean cancelled, String s, Throwable exception) {
                              cancelButton.removeActionListener(listener);
                              label.setText("done");
                          }
                      };
                      cancelButton.addActionListener(listener);
                      backgroundExec.execute(task);
                  }
              });
      }


#+END_SRC



*** Fork/Join
#+BEGIN_SRC java
  forkJoinAlgorithm() {
     split tasks;
     fork the tasks;
     join the tasks;
     compose the results;
  }



  doRecursiveTask(input) {
          if (the task is small enough to be handled by a thread) {
                  compute the small task;
                  if there is a result to return, do so  ;
          } else {
              divide (i.e., fork) the task into two parts;
              call compute() on first task, join() on second task, combine both results and return;
          }
   }


#+END_SRC

**** ForkJoinPool
| void execute(ForkJoinTask<?> task)                                                                                                                                                                                 | Executes a given task asynchronously.                                                                                    |
| <T> T invoke(ForkJoinTask<T> task)                                                                                                                                                                                 | Executes the given task and returns the computed result.                                                                 |
| <T> List<Future<T>>  invokeAll(Collection<? extends  Callable<T>> tasks)                                                                                                                                           | Executes all the given tasks and returns a list of future objects when all the tasks are completed.                      |
| boolean isTerminated()                                                                                                                                                                                             | Returns true if all the tasks are completed.                                                                             |
| int getParallelism() int getPoolSize()                                                                                                                                                                             | long getStealCount() Status checking methods.                                                                            |
| int getActiveThreadCount() <T> ForkJoinTask<T> submit(Callable<T> task) <T> ForkJoinTask<T> submit(ForkJoinTask<T> task) ForkJoinTask<?> submit(Runnable task) <T> ForkJoinTask<T> submit(Runnable task, T result) | Executes a submitted task. Overloaded versions take different types of tasks; returns a Task object or a  Future object. |

ForkJoinTask

| boolean cancel(boolean mayInterruptIfRunning)                                               | Attempts to cancel the execution of the task.                                                       |
| ForkJoinTask<V> fork()                                                                      | Executes the task asynchronously.                                                                   |
| V join()                                                                                    | Returns the result of the computation when the computation is done.                                 |
| V get()                                                                                     | Returns the result of the computation; waits if the computation is not complete.                    |
| V invoke() static <T extends ForkJoinTask<?>>  Collection<T> invokeAll(Collection<T> tasks) | Starts the execution of the submitted tasks; waits until computation complete, and returns results. |
| boolean isCancelled()                                                                       | Returns true if the task is cancelled.                                                              |
| boolean isDone()                                                                            | Returns true if the task is completed.                                                              |

Subclasses: RecursiveTask<v> , RecursiveAction

Extend each task from either RecursiveTask<v>, RecursiveAction and override compute()
Either split the tasks and execute using fork() or invokeAll() or return the result

#+BEGIN_SRC java
  import java.util.concurrent.*;

  // This class illustrates how we can compute sum of 1..N numbers using fork/join framework.
  // The range of numbers are divided into half until the range can be handled by a thread.
  // Once the range summation completes, the result gets summed up together.
  class SumOfNUsingForkJoin {
      private static long N = 1000_000;
      // one million - we want to compute sum
      // from 1 .. one million
      private static final int NUM_THREADS = 10;
      // number of threads to create for
      // distributing the effort
      // This is the recursive implementation of the algorithm;inherit from RecursiveTask
      // instead of RecursiveAction since we're returning values.
      static class RecursiveSumOfN extends RecursiveTask<Long> {
          long from, to;
          // from and to are range of values to sum-up
          public RecursiveSumOfN(long from, long to) {
              this.from = from;
              this.to = to;
          }
          // the method performs fork and join to compute the sum.
          // if the range of values can be summed by a thread
          // (remember that we want to divide the summation task equally among NUM_THREADS)
          // then, sum the range of numbers from..to using a simple for loop
          // otherwise, fork the range and join the results
          public Long compute() {
              if( (to - from) <= N/NUM_THREADS) {
                  // the range is something that can be handled by a thread, so do summation
                  long localSum = 0;
                  // add in range 'from' .. 'to' inclusive of the value 'to'
                  for(long i = from; i <= to; i++) {
                      localSum += i;
                  }
                  System.out.printf("\t Summing of value range %d to %d is %d %n", from,to, localSum);
                  return localSum;
              }
              else {
                  // no, the range is big for a thread to handle, so fork the computation
                  // we find the mid-point value in the range from..to
                  long mid = (from + to)/2;
                  System.out.printf("Forking computation into two ranges: " + "%d to %d and %d to %d %n", from, mid, mid, to);
                  // determine the computation for first half with the range from..mid
                  RecursiveSumOfN firstHalf = new RecursiveSumOfN(from, mid);
                  // now, fork off that task
                  firstHalf.fork();
                  // determine the computation for second half with the range mid+1..to
                  RecursiveSumOfN secondHalf = new RecursiveSumOfN(mid + 1, to);
                  long resultSecond = secondHalf.compute();
                  // now, wait for the first half of computing sum to
                  // complete, once done, add it to the remaining part
                  return firstHalf.join() + resultSecond;
              }
          }
      }
      public static void main(String []args) {
          // Create a fork-join pool that consists of NUM_THREADS
          ForkJoinPool pool = new ForkJoinPool(NUM_THREADS);
          // submit the computation task to the fork-join pool
          long computedSum = pool.invoke(new RecursiveSumOfN(0, N));
          // this is the formula sum for the range 1..N
          long formulaSum = (N * (N + 1)) / 2;
          // Compare the computed sum and the formula sum
          System.out.printf("Sum for range 1..%d; computed sum = %d, formula sum = %d %n", N, computedSum, formulaSum);
      }
  }

  /**

  Forking computation into two ranges: 0 to 500000 and 500000 to 1000000
  Forking computation into two ranges: 0 to 250000 and 250000 to 500000
  Forking computation into two ranges: 0 to 125000 and 125000 to 250000
  Forking computation into two ranges: 0 to 62500 and 62500 to 125000
  Summing of value range 0 to 62500 is 1953156250
  Summing of value range 62501 to 125000 is 5859406250
  Forking computation into two ranges: 125001 to 187500 and 187500 to 250000
  Summing of value range 125001 to 187500 is 9765656250
  Summing of value range 187501 to 250000 is 13671906250
  Forking computation into two ranges: 250001 to 375000 and 375000 to 500000
  Forking computation into two ranges: 250001 to 312500 and 312500 to 375000
  Summing of value range 250001 to 312500 is 17578156250
  Summing of value range 312501 to 375000 is 21484406250
  Forking computation into two ranges: 375001 to 437500 and 437500 to 500000
  Summing of value range 375001 to 437500 is 25390656250
  Summing of value range 437501 to 500000 is 29296906250
  Forking computation into two ranges: 500001 to 750000 and 750000 to 1000000
  Forking computation into two ranges: 500001 to 625000 and 625000 to 750000
  Forking computation into two ranges: 500001 to 562500 and 562500 to 625000
  Summing of value range 500001 to 562500 is 33203156250
  Summing of value range 562501 to 625000 is 37109406250
  Forking computation into two ranges: 625001 to 687500 and 687500 to 750000
  Summing of value range 625001 to 687500 is 41015656250
  Summing of value range 687501 to 750000 is 44921906250
  Forking computation into two ranges: 750001 to 875000 and 875000 to 1000000
  Forking computation into two ranges: 750001 to 812500 and 812500 to 875000
  Summing of value range 750001 to 812500 is 48828156250
  Summing of value range 812501 to 875000 is 52734406250
  Forking computation into two ranges: 875001 to 937500 and 937500 to 1000000
  Summing of value range 875001 to 937500 is 56640656250
  Summing of value range 937501 to 1000000 is 60546906250
  Sum for range 1..1000000; computed sum = 500000500000, formula sum = 500000500000

  ,*/
#+END_SRC

#+BEGIN_SRC java
  import java.util.concurrent.*;
  //This class illustrates how we can search a key within N numbers using fork/join framework
  // (using RecursiveAction).
  //The range of numbers are divided into half until the range can be handled by a thread.
  class SearchUsingForkJoin {
      private static int N = 10000;
      private static final int NUM_THREADS = 10;
      // number of threads to create for
      // distributing the effort
      private static int searchKey= 100;
      private static int[] arrayToSearch;
      // This is the recursive implementation of the algorithm;
      // inherit from RecursiveAction
      static class SearchTask extends RecursiveAction {
          private static final long serialVersionUID = 1L;
          int from, to;
          // from and to are range of values to search
          public SearchTask(int from, int to) {
              this.from = from;
              this.to = to;
          }
          public void compute() {
              //If the range is smaller enough to be handled by a thread,
              //we search in the range
              if( (to - from) <= N/NUM_THREADS) {
                  // add in range 'from' .. 'to' inclusive of the value 'to'
                  for(int i = from; i <= to; i++) {
                      if(arrayToSearch[i] == searchKey)
                          System.out.println("Search key found at index:" +i);
                  }
              }
              else {
                  // no, the range is big for a thread to handle,
                  // so fork the computation
                  // we find the mid-point value in the range from..to
                  int mid = (from + to)/2;
                  System.out.printf("Forking computation into two ranges: " + "%d to %d and %d to %d %n", from, mid, mid+1, to);
                  //invoke all the subtasks
                  invokeAll(new SearchTask(from, mid),new SearchTask(mid + 1, to));
              }
          }
      }

      public static void main(String []args) {
          //intantiate the array to be searched
          arrayToSearch = new int[N];
          //fill the array with random numbers
          for(int i=0; i<N; i++){
              arrayToSearch[i] = ThreadLocalRandom.current().nextInt(0,1000);
          }
          // Create a fork-join pool that consists of NUM_THREADS
          ForkJoinPool pool = new ForkJoinPool(NUM_THREADS);
          // submit the computation task to the fork-join pool
          pool.invoke(new SearchTask(0, N-1));
      }
  }
  /**

  Forking computation into two ranges: 0 to 4999 and 5000 to 9999
  Forking computation into two ranges: 0 to 2499 and 2500 to 4999
  Forking computation into two ranges: 5000 to 7499 and 7500 to 9999
  Forking computation into two ranges: 2500 to 3749 and 3750 to 4999
  Forking computation into two ranges: 0 to 1249 and 1250 to 2499
  Forking computation into two ranges: 2500 to 3124 and 3125 to 3749
  Forking computation into two ranges: 7500 to 8749 and 8750 to 9999
  Forking computation into two ranges: 5000 to 6249 and 6250 to 7499
  Forking computation into two ranges: 8750 to 9374 and 9375 to 9999
  Forking computation into two ranges: 5000 to 5624 and 5625 to 6249
  Forking computation into two ranges: 7500 to 8124 and 8125 to 8749
  Forking computation into two ranges: 3750 to 4374 and 4375 to 4999
  Search key found at index:4736
  Search key found at index:2591
  Forking computation into two ranges: 1250 to 1874 and 1875 to 2499
  Search key found at index:1315
  Forking computation into two ranges: 0 to 624 and 625 to 1249
  Search key found at index:445
  Search key found at index:9402
  Search key found at index:9146
  Fvorking computation into two ranges: 6250 to 6874 and 6875 to 7499
  Search key found at index:6797
  Search key found at index:7049
  Search key found at index:862
   */
#+END_SRC


** Garbage Collection
Objects are maintained in memory until live references to them exist in the system

If a reference is stored in a collection and not removed, the object will stay in the memory. This can lead to a  memory leak

protected void finalize() is called on objects when they are garbage collected,
it is preferable to use it only for deallocating resources and not perform any business logiv since the object might never get garbage collected


** Java Virtual Machine
JVM represents not just virtual hardware but an os as well
Compiler convertes java files into bytecode files (each class including inner class has a bytecode file)
which are interpreted by the jvm

Just-in-time compilers take bytecodes being interpeted and compile them into native code.
Priority is given to more frequently used code

JVM verifies all bytecode before loading the class. Checks include incorrect type coercions, incorrect jumps (making sure they were compiled by the actual java compiler)


** Javadoc
Document each member with a documentation block
/**
  {@inheritDoc} Adds documentation of the nearest superclass or implmented interface
  Text {@link package#class}
  @return value
  @param argument
*/

Architectural documentation can be placed in package-info.java in the directory


** Collections

A TreeSet is a collection type which can be initialized with a comparator object which keeps element sorted

Some Collection(all?) classes which implement a conceptual variant of an interface may throw a UnsupportedOperationException which extends RuntimeException and does not need to be caught
This was intended to keep heirarchies simpler


hashCode() and equals() must be overriden to function correctly for HashSet, HashMap
the methods hashCode() and equals() need to be consistent for a class.
For practical purposes, ensure that you follow this one rule: the hashCode() method should return the same hash value for two objects  if the equals() method returns true for them

*** Collection interface
| Method                                              | Description                                                                                                       |
| boolean add(Element elem)                           | Adds elem into the underlying container.                                                                          |
| void clear()                                        | Removes all elements from the container.                                                                          |
| boolean isEmpty()                                   | Checks whether the container has any elements or not.                                                             |
| Iterator<Element> iterator()                        | Returns an Iterator<Element> object for iterating over the container.                                             |
| boolean remove(Object obj)                          | Removes the element if obj is present in the container.                                                           |
| int size()                                          | Returns the number of elements in the container.                                                                  |
| Object[] toArray()                                  | Returns an array that has all elements in the container.                                                          |
| boolean addAll( Collection<? extends Element> coll) | Adds all the elements in coll into the underlying container.                                                      |
| boolean containsAll(Collection<?> coll)             | Checks if all elements given in coll are present in the underlying container.                                     |
| boolean removeAll(Collection<?> coll)               | Removes all elements from the underlying container that are also present in coll.                                 |
| boolean retainAll(Collection<?> coll)               | Retains elements in the underlying container only if they are also present in coll; it removes all other elements |


*** Concrete Classes

| Interfaces | Hash table Implementations | Resizable array Implementations | Tree Implementations | Linked list Implementations | Hash table + Linked list Implementations |
| Set        | HashSet                    |                                 | TreeSet              |                             | LinkedHashSet                            |
| List       |                            | ArrayList                       |                      | LinkedList                  |                                          |
| Queue      |                            |                                 |                      |                             |                                          |
| Deque      |                            | ArrayDeque                      |                      | LinkedList                  |                                          |
| Map        | HashMap                    |                                 | TreeMap              |                             | LinkedHashMap                            |

| Concrete Class | Description                                                                                                                                                                                                                                                                                                     |
| ArrayList      | Internally implemented as a resizable array. This is one of the most widely used concrete classes. Fast to search but slow to insert or delete. Allows duplicates.                                                                                                                                              |
| LinkedList     | Internally implements a doubly-linked list data structure. Fast to insert or delete elements but slow for searching elements. Additionally LinkedList can be used when you need a stack (LIFO) or queue (FIFO) data structure. Allows duplicates.                                                               |
| HashSet        | Internally implemented as a hash-table data structure. Used for storing a set of elements—it does not allow storing duplicate elements. Fast for searching and retrieving elements. It does not maintain any order for stored elements.                                                                      |
| TreeSet        | Internally implements a red-black tree data structure. Like HashSet TreeSet does not allow storing duplicates. However unlike HashSet it stores the elements in a sorted order. It uses a tree data structure to decide where to store or search the elements and the position is decided by the sorting order. |
| HashMap        | Internally implemented as a hash-table data structure. Stores key and value pairs. Uses hashing for finding a place to search or store a pair. Searching or inserting is very fast. It does not store the elements in any order.                                                                                |
| TreeMap        | Internally implemented using a red-black tree data structure. Unlike HashMap TreeMap stores the elements in a sorted order. It uses a tree data structure to decide where to store or search for keys and the position is decided by the sorting order.                                                         |
| PriorityQueue  | Internally implemented using heap data structure. A PriorityQueue is for retrieving elements based on priority. Irrespective of the order in which you insert when you remove the elements the highest priority element will be retrieved first.                                                                |


*** Queues/Deques
LinkedList<> works exactly like a Queue using add(), remove()

Rang view methods
int i = list.subList(fromIndex, toIndex).indexOf(o);
int j = list.subList(fromIndex, toIndex).lastIndexOf(o);

**** Deque Methods
| Method                 | Short Description                                              |
| void addFirst(Element) | Adds the Element to the front of the Deque.                    |
| void addLast(Element)  | Adds the Element to the last of the Deque.                     |
| Element removeFirst()  | Removes an element from the front of the Deque and returns it. |
| Element removeLast()   | Removes an element from the last of the Deque and returns it.  |
| Element getFirst()     | Returns the first element from the Deque does not remove.      |
| Element getLast()      | Returns the last element from the Deque does not remove        |


**** Deque Methods when created with a finite capacity
| Method                      | Short Description                                                                                     |
| boolean offerFirst(Element) | Adds the Element to the front of the Deque if it is not violating capacity constraint.                |
| boolean offerLast(Element)  | Adds the Element to the end of the Deque if it is not violating capacity constraint.                  |
| Element pollFirst()         | Removes an element from the front of the Deque and returns it; if the Deque is empty it returns null. |
| Element pollLast()          | Removes an element from the end of the Deque and returns it; if the Deque is empty it returns null.   |
| Element peekFirst()         | Returns the first element from the Deque but does not remove it; returns null  if Deque is empty.     |
| Element peekLast()          | Returns the last element from the Deque but does not remove it; returns null  if Deque is empty.      |


*** Set Types

HashSet, does not store elements in order, quick Insertion

TreeSet, stores elements in order.

Collection operations when applied to Sets
| s1.containsAll(s2) | returns true if s2 is a subset of s1. (s2 is a subset of s1 if set s1 contains all of the elements in s2.)                                                                             |
| s1.addAll(s2)      | transforms s1 into the union of s1 and s2. (The union of two sets is the set containing all of the elements contained in either set.)                                                  |
| s1.retainAll(s2)   | transforms s1 into the intersection of s1 and s2. (The intersection of two sets is the set containing only the elements common to both sets.)                                          |
| s1.removeAll(s2)   | transforms s1 into the (asymmetric) set difference of s1 and s2. (For example, the set difference of s1 minus s2 is the set containing all of the elements found in s1 but not in s2.) |


**** SortedSet
#+BEGIN_SRC java
public interface SortedSet<E> extends Set<E> {
    // Range-view
    SortedSet<E> subSet(E fromElement, E toElement);
    SortedSet<E> headSet(E toElement);
    SortedSet<E> tailSet(E fromElement);

    // Endpoints
    E first();
    E last();

    // Comparator access
    Comparator<? super E> comparator();
}

//Thus, the following one-liner tells you how many words between "doorbell" and "pickle", including doorbell and pickle, are contained in the dictionary.

count = dictionary.subSet("doorbell", "pickle\0").size();
//A similar technique can be used to view an open interval, which contains neither endpoint. The open-interval view from lowEndpoint to highEndpoint is the half-open interval from successor(lowEndpoint) to highEndpoint. Use the following to calculate the number of words between "doorbell" and "pickle", excluding both.

count = dictionary.subSet("doorbell\0", "pickle").size();

SortedSet<String> volume1 = dictionary.headSet("n"); //a-m
SortedSet<String> volume2 = dictionary.tailSet("n"); //n-z
#+END_SRC

*** Map Types
HashMap<> does not order elements, quick insertion, search
TreeMap<> orders elements using red-black tree.
LinkedHashMap orders elements according to insertion

keySet(), valueSet() return Set<> of keys, values respectively

**** SortedMap
#+BEGIN_SRC java
public interface SortedMap<K, V> extends Map<K, V>{
    Comparator<? super K> comparator();
    SortedMap<K, V> subMap(K fromKey, K toKey);
    SortedMap<K, V> headMap(K toKey);
    SortedMap<K, V> tailMap(K fromKey);
    K firstKey();
    K lastKey();
}
#+END_SRC

**** NavigableMap Interface
Has methods for retreiving elements using various criteria e.g. TreeMap
#+BEGIN_SRC java
  import java.util.*;
  public class NavigableMapTest {
      public static void main(String []args) {
          NavigableMap<Integer, String> examScores = new TreeMap<Integer, String>();
          examScores.put(90, "Sophia");
          examScores.put(20, "Isabella");
          examScores.put(10, "Emma");
          examScores.put(50, "Olivea");
          System.out.println("The data in the map is: " + examScores);
          System.out.println("The data descending order is: " + examScores.descendingMap());
          System.out.println("Details of those who passed the exam: " +          examScores.tailMap(40));
          System.out.println("The lowest mark is: " + examScores.firstEntry());
      }
  }

  /** It prints the following:
      The data in the map is: {10=Emma, 20=Isabella, 50=Olivea, 90=Sophia}
      The data descending order is: {90=Sophia, 50=Olivea, 20=Isabella, 10=Emma}
      Details of those who passed the exam: {50=Olivea, 90=Sophia}
      The lowest mark is: 10=Emma

      In this program, you have a NavigableMap<Integer, String> that maps the exam score and the name of the person.
      You create a TreeMap<Integer, String> to actually store the exam scores. By default, a TreeMap stores data in ascending order.
      If you want the data in descending order, you just have to use the descendingMap() method (or descendingKeySet() if you are only interested in the keys).
      Given the passing score is 40, you might want to get the map with data of those who failed in the exam.
      For that, you can use the headMap() method with the key value 40 (since the data is in ascending order, you want to get the “head” part of the map from the given position).
      Similarly, to get the data of those who passed the exam, you can use the tailMap() method.
      If you want the immediate ones above and below the passing score, you can use the higherEntry() and lowerEntry() methods, respectively.
      The firstEntry() and lastEntry() methods give the entries with lowest and highest key values.*/

#+END_SRC



*** Iterating

**** Iterator Interface
Has hasNext(), next(), remove()

next() MUST be called before any call to remove()

| Method                | Short Description                                                                            |
| boolean hasPrevious() | Checks if the iterator has more elements to traverse in reverse direction.                   |
| Element previous()    | Moves the iterator to the next element and returns that (next) element in reverse direction. |
| int nextIndex()       | Returns the index of the next element in the iteration in forward direction.                 |
| int previousIndex()   | Returns the index of the next element in the iteration in reverse direction.                 |
| void set(Element)     | Sets the last element visited (using next or previous); it replaces the existing element.    |
| void add(Element)     | Adds the element into the list at the current iteration position.                            |

In a foreach loop, more than 1 reference is not supported.
e.g. this would fail
throws concurrentModificationException
#+BEGIN_SRC java
  for(String word : list) {
      if(word.equals("bears.")) {
          word = "kitty cats";
          list.add("kitty cats");
      }
  }

#+END_SRC


*** Comparable/Comparator Interface
It is vital that the comparator is consistent with the equals method especially when inserting elements into a sorted collection.
Interface Comparable {
  int compareTo(obj); //Return 1 when this > obj, -1 when this < obj and 0 when this==obj
}

Interface Comparator {
  int compare (obj1, obj2);
}


*** java.utils.Arrays
Utility methods for arrays similar to utils.Collections

binarySearch should only be called on sorted arrays.
The list returned from asList() cannot be added to or removed from but existing elements can be modified.

*** java.utils.Collections
Has several utility methods for manipulating Collections

| Method                                                               | Short Description                                                                                                                                                                            |
| int binarySearch( List<? extends Comparable<? super  T>> list T key) | Looks for the key in List. If found it returns a value >= 0; otherwise it returns a negative value. It has an overloaded version that also takes a Comparator object for comparing elements. |
| void copy( List<? super T> dest List<? extends T> src)               | Copies all the elements from src List to dest List.                                                                                                                                          |
| void fill(List<? super T> list T obj)                                | Fills the whole list with the value obj.                                                                                                                                                     |
| T max(Collection<? extends T> coll)                                  | Returns the max element in the list. It has an overloaded version that also takes a Comparator object for comparing elements.                                                                |
| T min(Collection<? extends T> coll)                                  | Returns the min element in the list. It has an overloaded version that also takes a Comparator object for comparing elements.                                                                |
| boolean replaceAll( List<T> list  T oldVal T newVal)                 | Replaces all occurrences of oldVal with newVal in list.                                                                                                                                      |
| void reverse(List<?> list)                                           | Reverses all the elements in the given list.                                                                                                                                                 |
| void rotate(List<?> list int distance)                               | Rotates the list given by the value distance.                                                                                                                                                |
| void shuffle(List<?> list)                                           | Shuffles elements in the list randomly.                                                                                                                                                      |
| void sort(List<T> list)                                              | Sorts the list in its natural order (i.e. by using the compareTo() method). It has an overloaded version that also takes a Comparator object for comparing elements.                         |
| void swap(List<?> list int i int j)                                  | Swaps the elements in the positions i and j in the list.                                                                                                                                     |


** Remote Method Invocation
java.rmi: a library for invoking methods on objects over the network
An RMI Registry keeps track of all the objects registered(hosted?) on a machine
Clients can access those objects provided they have the address and port

#+BEGIN_SRC java
Registry useRegistry = LocateRegistry.getRegistry(fromHost);
return ((StatRecorder) useRegistry.lookup("Recorder"));
#+END_SRC
RMI also has functionality provide class files to clients in case they are not available.


** Object Serialization
Serializable interface must be implemented(doesn't contain any methods only signature needs to be altered)
Unserialable fields can be marked with a transient keyword
Static fields are not serialized and unaffected by deserialization.

When an object is deserialized no constructors are called for serializable classes in the inheritance chain but they are called for any ancestors which are not serializable.

private static final serialVersionUID can be declared and set which contains a hash of class methods, return types etc
it is used to make that the object created after deserialization has the fields, methods etc as when it was serialized otherwise thwos an InvalidClassException


* Git

Each commit creates a commit object which contains metadata and pointers to the previous commit and a tree object containing change details.

The tree object contains list of pointers to blob objects which contain the contents of files committed

Check status: git status

HEAD: current branch

Remove file: git rm

Move file: git mv [from] [to]

Revert File: git checkout -- [file]

Adding alias: git config --global alias.[name] 'text'
              git config --global alias.[name] '!external_cmd'
** History
git log -p[to see diffs] -num[ show only num changes]

git log --stat | --shortstat Shows list of changed files, number of changes in each

git log --pretty=[oneline|short|full|fuller]

git log --pretty=format:""
%H	Commit hash
%h	Abbreviated commit hash
%T	Tree hash
%t	Abbreviated tree hash
%P	Parent hashes
%p	Abbreviated parent hashes
%an	Author name
%ae	Author e-mail
%ad	Author date (format respects the --date= option)
%ar	Author date, relative
%cn	Committer name
%ce	Committer email
%cd	Committer date
%cr	Committer date, relative
%s	Subject


--since, --after	Limit the commits to those whose CommitDate was made on-or-after the specified date/time.
--until, --before	Limit the commits to those whose CommitDate was made on-or-before the specified date/time.
--author	        Only show commits in which the author entry matches the specified string.
--committer	        Only show commits in which the committer entry matches the specified string.


** Staging
Stage file: git add <file>

Unstage file: git reset HEAD <file>

Stage file partial: git add -p


** Stashing
Save changes for later: git stash

List stashes: git stash list

Apply stash : git stash apply @{2}[stash id] --index [if the files staged while saving should be re-staged as well]

Delete stash: git stash drop [id]

Get diff from stash: git stash show -p stash@{0}

Unapply stash: git stash show -p stash@{0} | git apply -R

Stash changes to a branch: git stash branch [name]

** Amending
git commit --amend

Rewrites the last commit

** Remote

List all remote destinations: git remote -v

Add remote dest: git remote add [shortname] [url]

Get data: git fetch [remote-name] (Does not merge data to the working directory)

Get data and merge: git pull [remote-name] (defaults to origin if cloned) [branch] (defaults to master)

Push data upstream: git push [remote-name] [branch] (defaults to master)

Show information about remote: git remote show [remote-name]

Rename remote: git remote rename [from] [to]

Remove remote: git remote rm [remote-name]

** Tags
Pointer to a point in commit history

List tags: git tag
           git tag -l 'v1.4.2.*'

Add tag: git tag -a [name] -m 'my tag' (Annotated, stores author message)
         git tag [name] (lightweight)

Add tag for a past version: git tag -a [name] -m 'message' [checksum]

Display tag: git show [tag-name]

Push tags to remote: git push [remote-name] [tag-name]

** Branches
Branch: a lightweight movable pointer to a commit object
The master branch(pointer) moves to the latest commit object after each commit

Create branch: git branch -b(to switch as well) [name]

Delete branch: git branch -d [-D](force delete) [name]

Merge branch with current: git merge [name]

Switch to branch: git checkout [name] (Changes the HEAD pointer)
switching also changes the contents of the directory to that point in commit history

List branches: git branch -v[displays last commit]

List merged/unmerged branches: git branch [--no-merged] [--merged]

*** Remote Branches
Branches can exist independently on remotes, they need to be pushed, pulled to make sure local versions are in sync

List Remote Branches: git branch -r

To pull from remote branch do git fetch [remote] [branch]

git merge [remote]/[branch]

To push
git push [remote] [mybranch]:[remote-branch]

Local branches can be based off remote branches
git checkout -b mybranch [remote]/[branch]
Doing this means any push, pull automatically merges from or uploads to the remote branch

Deleting a remote branch
git push [remote] :[branch]


*** Rebasing
git checkout experiment

git rebase master

Applies patches from the rebase branch starting at the common ancestor
and if successful alters the commit history to look like the original branch is linear progression from the rebase branch.

Still needs git checkout master? and git merge experiment?



Result is same as merge but results in a cleaner commit history

Rebasing can also be done with a branch which is not a direct descendent of the rebase branch using a intermediary ancestor
git rebase --onto [rebase] [ancestor] [branch]


*** Conflicts
If conflict produced after merge
Resolve conflict in each file
and git add [file]

git status to check if no conflicts are left

git commit

*** Model
Going to a branch pointing to a older commit and commiting changes forks from the commit list


                        master
                          |
    Commit -> Commit -> Commit -> Commit -- newbranch -- HEAD

    switch to master and commit



                               Commit -- master -- HEAD
                              /
    Commit -> Commit -> Commit
                              \
                               Commit -- newbranch


* CSS
** Tables and Lists
*** nth-child nth-last-child
tr:nth-child: [n, odd, even, an+b]
#+BEGIN_SRC css
  tr:nth-child(-n + 3) {
  /* matches first two rows of any table*/
  }
  thead:first-child, tbody:nth-last-child(1) {
      border: none;
  }
#+END_SRC


** Color
Hue Saturation Lightness
hsl(:Hue [0-360], :Saturation [0%-100%], :Lightness [0%-100%])
or
hsl(:Hue [0-360], :Saturation [0%-100%], :Lightness [0%-100%], :Alpha [0-1.0])

** Background
Can specify multiple layers
#+BEGIN_SRC css
  .boxBG {
      background-image: url(img1.jpg), url(img2.jpg);
      background-position: center bottom, left top;
      background-repeat: no-repeat;
  }
#+END_SRC

** Fitting video or image elements
[-ms-object-fit, object-fit, -moz-object-fit, -o-object-fit, -webkit-object-fit]: [fill, contain, cover, none, scale-down]
image-resolution: 300dpi (pixels per inch)


** Resetting browser Defaults
#+BEGIN_SRC css
  * {
      vertical-align: baseline;
      font-weight: inherit;
      font-family: inherit;
      font-style: inherit;
      font-size: 100%;
      border: 0 none;
      outline: 0;
      padding: 0;
      margin: 0;
  }

#+END_SRC

** Transitions
Animate changes to css properties automatically
-webkite-transition: height 10s ....

** Transforms
Apply 2d, 3d transformations to elements
can be specified as a transition property

<div style="transform: rotate(90deg); transform-origin: bottom left;">
  <iframe src="http://www.google.com/" width="500" height="600"></iframe>
</div>

** Animations

Animation properties
#+BEGIN_SRC css
  .elem {
      animation-duration: 3s;
      animation-name: slidein;
      animation-iteration-count: infinite;
      animation-direction: alternate;
  }
  // from/to aliases for 0%/100%
  @keyframes slidein {
      from {
          margin-left: 100%;
          width: 300%;
      }

      75% {
          font-size: 300%;
          margin-left: 25%;
          width: 150%;
      }

      to {
          margin-left: 0%;
          width: 100%;
      }
  }
#+END_SRC

Reset animation
#+BEGIN_SRC javascript
element.addEventListener('webkitAnimationEnd', function(){
    this.style.webkitAnimationName = '';
}, false);

document.getElementById('button').onclick = function(){
    element.style.webkitAnimationName = 'shake';
    // you'll probably want to preventDefault here.
};
#+END_SRC
* Overtone
** Instruments
*** overtone.inst.drum
Drums kick kick2 kick3 kick4 dub-kick dry-kick
small-hat closed-hat close-hat2 open-hat
hat3 soft-hat noise-hat round-kick snare
snare2 noise-snare tone-snare tom clap bing
dance-kick quick-kick haziti-clap
*** overtone.inst.piano
Piano piano
overtone.inst.sampled-piano
Sampled Piano sampled-piano
overtone.inst.sampler
Sampler granular
*** overtone.inst.bass
Bass bass grunge-bass vintage-bass daf-bass
***  overtone.inst.synth
Synth ticker ping tb303 mooger rise-fall-pad
pad overpad buzz ks1 ks-stringer fm-demo
harmonic-swimming whoahaha bubbles supersaw
cs80lead simple-flute

** Server
*** Startup
boot-server boot-internal-server
boot-external-server
connect-external-server
*** Shutdown
kill-server
*** Control
stop clear stop-all clear-all
*** OSC
Communication snd recv clear-msg-queue at
snd-immediately
*** Diagnostic
server-status server-info
server-opts server-connected?
server-disconnected?
server-connecting?
internal-server? external-server?
connection-info server-sample-rate
server-num-output-buses
server-num-input-buses
server-num-audio-buses
server-num-buffers
ensure-connected!
*** Debug
sc-osc-log-on sc-osc-log-off
sc-osc-log sc-debug-on
sc-debug-off external-server-log
sc-osc-debug-on sc-osc-debug-off
** Envelope
done free-self pause-self free-self-when-done
pause-self-when-done pause free env-gen linen
i-env-gen
** Control signals using buses
#+BEGIN_SRC clojure
(definst test-inst [freq 440 dur 2 in-bus 2]
  (* (sin-osc [freq freq]) (env-gen (perc 0.01 dur) :gate (in:kr in-bus)))
  )


(stop)
(def test-bus (control-bus))
(defsynth test-trig [bus 2 rate 2]
  (out:kr bus (impulse rate))
  )

(def t-trig (test-trig test-bus))
(def t (test-inst 200 :in-bus test-bus))

(ctl t-trig :rate 1)
(ctl t :freq 300)
(ctl t :dur 4)


(out:kr 2 (impulse 2))


(defonce drum-g (group "drums group"))
(defonce drum-input-g (group "drum input signal producers" :head drum-g))
(defonce drum-output-g (group "drum instruments" :after drum-input-g))



(defonce trig-bus (audio-bus))
(defsynth bus-test-consumer [bus 5]
  (out:ar 0 (in:ar bus))
  )
(defsynth bus-test-producer [bus 5]
  (out:ar bus (sin-osc))
  )
(bus-test-producer)
(bus-test-consumer)
(def b1 (bus-test-producer [:tail drum-input-g]))
(def b2 (bus-test-consumer [:tail drum-output-g]))
#+END_SRC



* Beats
4/4 1 2 3 4
    k s k s

5/4 1 2 3 4 5
    k k s k s

6/8 1 2 3 4 5 6
    k     s
* SuperCollider
** Major Scale ratios
[1, 9/8, 5/4, 4/3, 3/2, 5/3, 16/15, 2/1]

** UGens
*** Oscillators
**** Low Frequency Oscillators
All of these are not band limited and can cause aliasing
LFPar, LFCub, LFTri, LFSaw, Impulse

Parabolic, cubic, triangle, saw
imulse has no curve at all, either max or zero amplitude
{ LFTri.ar(400,0,0.1) !2}.scope(1, zoom: 4);


LFPulse, VarSaw, SyncSaw
LFPulse has zero attack, decay
{ LFPulse.ar(MouseX.kr(100,15000, 1),0,0.5,0.1)!2}.scope(1, zoom: 4);

SyncSaw has a guttural edge to it


**** Band Limited Oscillators
SinOsc, Blip, Saw, Pulse

***** Klang - Sine Oscillator Bank
{ Klang.ar(`[ [800, 1000, 1200],[0.3, 0.3, 0.3],[pi,pi,pi]], 1, 0) * 0.4}.scope(1);


***** Band Limited Impulse (Buzz/Blip) (WhiteNoise based on fundamental?)
All harmonics have equal amplitude
{ Blip.ar(XLine.kr(20000,200,6),100,0.2) }.play;


*** Noise Generators
LFNoise0, LFNoise1, LFNoise2, LFClipNoise
{ LFClipNoise.ar(MouseX.kr(200, 10000, 1), 0.125) }.scope(1);
{ LFNoise0.ar(MouseX.kr(200, 10000, 1), 0.25) }.scope(1);
{ LFNoise1.ar(MouseX.kr(200, 10000, 1), 0.25) }.scope(1);
{ LFNoise2.ar(MouseX.kr(200, 10000, 1), 0.25) }.scope(1);


ClipNoise, WhiteNoise, PinkNoise, BrownNoise, GrayNoise (Broad Spectrum)
{ ClipNoise.ar(0.2) }.scope(1);
{ WhiteNoise.ar(0.2) }.scope(1);
{ PinkNoise.ar(0.4) }.scope(1);
{ BrownNoise.ar(0.2) }.scope(1);
{ GrayNoise.ar(0.2) }.scope(1);

Dust, Dust2 Impulse noise
{ Dust.ar(MouseX.kr(1,10000,1), 0.4) }.scope(1, zoom:4);
{ Dust2.ar(MouseX.kr(1,10000,1), 0.4) }.scope(1, zoom:4);

Crackle (Chaotic)
{ Crackle.ar(MouseX.kr(1,2), 0.5) }.scope(1);


*** Filters
**** Pass Filters
Low Pass Filter (LPF) rejects frequencies below threshold
{ LPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2) !2}.scope(1);
High Pass Filter (HPF) rejects frequencies above threshold
{ HPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2) !2}.scope(1);

**** Band Filters
Band Pass Filter (BPF) allows only frequencies in band
{ LPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2) !2}.scope(1);  //Mouse is centre frequency,
//0.2 is The reciprocal of Q. Q is conventionally defined as cutoffFreq / bandwidth, meaning rq = (bandwidth / cutoffFreq).
Band Reject Filter (BRF) rejects frequencies in the band

**** Resonant Filters
Resonant Low Pass Filter (RLPF) same as LPF but gives an extra amplitude at the cutoff frequency
{ RLPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1);
Resonant High Pass Filter (RHPF) inverse of RLPF
{ RHPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1);

{ RLPF.ar(Pulse.ar([100,250],0.5,0.1), XLine.kr(8000,400,5), 0.05) }.scope(1);

***** Resonz Resonant Band Pass Filter
 { Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(1, 0.001, 8)) }.scope(1);

***** Ringz same as resonz but the bandwidth is expressed as ring time
   { Ringz.ar(WhiteNoise.ar(0.005), XLine.kr(100,3000,10), 0.5) }.scope(1, zoom:4);

*****   Klank Resonant Filter Bank
{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;
A Ref to an Array of three Arrays:
frequencies:
An Array of filter frequencies.
amplitudes:
an Array of filter amplitudes, or nil. If nil, then amplitudes default to 1.0.
ring times:
an Array of 60 dB decay times for the filters.
All subarrays, if not nil, should have the same length.

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;

{ Klank.ar(`[ {exprand(200, 4000)}.dup(12), nil, nil ], PinkNoise.ar(0.007)) }.scope(1);

{ Klank.ar(`[ (1..13)*200, 1/(1..13), nil ], PinkNoise.ar(0.01)) }.scope(1);

{ Klank.ar(`[ (1,3..13)*200, 1/(1,3..13), nil ], PinkNoise.ar(0.01)) }.scope(1);

**** NonLinear Filters
Median, Slew seem to be good for removing noise
/ a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1);
// after applying median filter
{ Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.scope(1);

// a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1);
// after applying slew rate limiter
{ Slew.ar(Saw.ar(500, 0.1) + Dust2.ar(100, 0.9),1000,1000) }.scope(1);



*** Reverb
FreeVerb
(
{
    // play with the room size
    var x;
    x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(2, 0.1));
    x = Pan2.ar(x, -0.2);
    x = [x[0], DelayC.ar(x[1], 0.01, 0.01)]; // de-correlate
    FreeVerb.ar(x, 0.75, 0.9, 0.4);
}.scope;
)
GVerb
(
{
    // play with the room size
    var x;
    x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(2, 0.1));
    GVerb.ar(x, 105, 5, 0.7, 0.8, 60, 0.1, 0.5, 0.4) + x;
}.scope;
)


*** Delays
DelayN, DelayL, DelayC - simple delays
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayN.ar(z, 0.1, 0.1, 1, z); // input is mixed with delay via the add input
}.scope(1, zoom: 4)
)

CombN, CombL, CombC - feedback delays
// used as an echo.
{ CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.scope(1, zoom:4);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1);

{ CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1);

{ CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1);

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1);

{ CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1);

{ CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1);

{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/100, 1/100, 3) }.play;
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/200, 1/200, 3) }.play;
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/300, 1/300, 3) }.play;
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/400, 1/400, 3) }.scope(1, zoom:4);


*** Controls
**** Decay/Decay2 Exponential decay/attack

{ WhiteNoise.ar * Decay.ar(Dust.ar(3), 0.9, 0.2) }.scope(1, zoom:4);
{ WhiteNoise.ar * Decay2.ar(Dust.ar(3), 0.2, 0.9, 0.2) }.scope(1, zoom:4);

**** PulseCount
Outputs a incremental signal using input signal until the reset signal is triggered

(
{
SinOsc.ar(
            PulseCount.ar(Impulse.ar(10), Impulse.ar(0.4)) * 200,
            0, 0.05
        )
}.scope(2, zoom:4);
)

**** PulseDivider
Outputs a pulse after receiving a certain number of triggers

(
{
    var p, a, b;
    p = Impulse.ar(8);
    a = SinOsc.ar(1200, 0, Decay2.ar(p, 0.005, 0.1));
    b = SinOsc.ar(600,  0, Decay2.ar(PulseDivider.ar(p, MouseX.kr(1,8).round(1)), 0.005, 0.5));

    [a, b] * 0.4
}.scope(2, zoom:4);
)


** LinExp
Maps linear range to exponential range


** Scheduling


Routine.play(clock, quant)
aTask.play(argClock, doReset, quant)

If a numeric value is returned by the function, used as the next scheduling time
*** SystemClock
SystemClock.sched(5, { "hello".postln });
SystemClock.schedAbs(TIMESTAMP, { "hello".postln });


*** TempoClock
Uses beats to measure time
(
var timeNow;
TempoClock.default.tempo = 2;    // 2 beats/sec, or 120 BPM
timeNow = TempoClock.default.beats;
"Time is now: ".post; timeNow.postln;
"Scheduling for: ".post; (timeNow + 5).postln;
TempoClock.default.schedAbs(timeNow + 5,
    { "Time is later: ".post; thisThread.clock.beats.postln; nil });
)



*** Routines
Set of instructions which can be scheduled
Execution is stopped when yield is called on an object, if the object is a number, it is used to schedule the next execution
(
SynthDef(\singrain, { |freq = 440, amp = 0.2, sustain = 1|
    var sig;
    sig = SinOsc.ar(freq, 0, amp) * EnvGen.kr(Env.perc(0.01, sustain), doneAction: 2);
    Out.ar(0, sig ! 2);    // sig ! 2 is the same as [sig, sig]
}).add;

r = Routine({
    var delta;
    loop {
        delta = rrand(1, 3) * 0.5;
        Synth(\singrain, [freq: exprand(200, 800), amp: rrand(0.1, 0.5), sustain: delta * 0.8]);
        delta.yield;
    }
});
)


*** Tasks
Can be started and stopped
(
t = Task({
    loop {
        [60, 62, 64, 65, 67, 69, 71, 72].do({ |midi|
            Synth(\singrain, [freq: midi.midicps, amp: 0.2, sustain: 0.1]);
            0.125.wait;
        });
    }
}).play;
)

// probably stops in the middle of the scale
t.stop;



*** Merging routines and tasks
(
var midi, dur;
midi = Routine({
    [60, 72, 71, 67, 69, 71, 72, 60, 69, 67].do({ |midi| midi.yield });
});
dur = Routine({
    [2, 2, 1, 0.5, 0.5, 1, 1, 2, 2, 3].do({ |dur| dur.yield });
});

SynthDef(\smooth, { |freq = 440, sustain = 1, amp = 0.5|
    var sig;
    sig = SinOsc.ar(freq, 0, amp) * EnvGen.kr(Env.linen(0.05, sustain, 0.1), doneAction: 2);
    Out.ar(0, sig ! 2)
}).add;

r = Task({
    var delta;
    while {
        delta = dur.next;
        delta.notNil
    } {
        Synth(\smooth, [freq: midi.next.midicps, sustain: delta]);
        delta.yield;
    }
}).play(quant: TempoClock.default.beats + 1.0);
)


** Patterns
*** Types
Pseq(list, repeats, offset)
return the list's values in order

Pshuf(list, repeats)
scramble the list into random order

Prand(list, repeats)
choose from the list's values randomly

Pxrand(list, repeats)
choose randomly, but never return the same list item twice in a row

Pwrand(list, weights, repeats)
like Prand, but chooses values according to a list of probabilities/weights

Other patterns generate values according to various parameters. In addition to these basic patterns, there is a whole set of random number generators that produce specific distributions, and also chaotic functions.

Pseries(start, step, length)
arithmetic series, e.g., 1, 2, 3, 4, 5

Pgeom(start, grow, length)
geometric series, e.g., 1, 2, 4, 8, 16

Pwhite(lo, hi, length)
random number generator, uses rrand(lo, hi) -- equal distribution

Pexprand(lo, hi, length)
random number generator, uses exprand(lo, hi) -- exponential distribution
Other patterns modify the output of value patterns. These are called FilterPatterns.

Pn(pattern, repeats)
repeat the pattern as many times as repeats indicates

Pstutter(n, pattern)
repeat individual values from a pattern n times. n may be a numeric pattern itself.


*** Evaluation
p = Pseries(0, 1, 10);
p.next;    // always returns the Pseries, not actual numbers

q = p.asStream;
q.next;    // calling this repeatedly gets the desired increasing integers


*** Utility functions
collect(func)
Applies the function to each return value from the pattern. Good for generic transformations.

select(func)
Preserve values from the output stream that pass the Boolean test; discard the rest.

reject(func)
Discard values from the output stream that pass the test; return the rest to the user.
// Arbitrary/custom operation: Turn each number into a two-digit hex string
Pwhite(0, 255, 20).collect({ |x| x.asHexString(2) }).do { |x| x.postln };

// Keep odd numbers in the result (which is now less than 20 items)
Pwhite(0, 255, 20).select({ |x| x.odd }).do { |x| x.postln };

// Throw out odd numbers in the result
Pwhite(0, 255, 20).reject({ |x| x.odd }).do { |x| x.postln };

clump(n)
Calling .clump on an array turns a flat array into a multilevel array. Similarly, .clump on a pattern gets n values from the pattern at once and returns all of them as an array. n can be a number or a numeric pattern.

flatten(levels)
The reverse operation: if a pattern returns an array, its values will be output one by one.
// A flat stream becomes an array of 4-item arrays

Pwhite(0, 255, 20).clump(4).do { |x| x.postln };

    // a two-dimensional array
Array.fill(5, { Array.fill(4, { rrand(1, 5) }) });

    // a pattern reading that array in sequence
p = Pseq(Array.fill(5, { Array.fill(4, { rrand(1, 5) }) }), 1);

    // the pattern returns several arrays
p.do { |x| x.postln };

    // flattening the pattern returns a one-dimensional stream of numbers
p.flatten.do { |x| x.postln };

drop(n)
Discard the first n values, and return whatever is left.

Pseries(1, 1, 20).drop(5).do { |x| x.postln };

differentiate
Return the difference between successive values: second - first, third - second, and so on.


*** Filters


** MIDI
MIDIClient.init; //Returns currently available midi devices

MIDIIn.connectAll; //Connects to all devices
MIDIdef(\noteEvent).[disable|enable|free]
MIDIdef(\noteEvent).permanent_(true|false) //determines if the def is removed after Server.stop

#+BEGIN_SRC java
  ~notes = Array.newClear(128);

  MIDIdef.noteOn(\noteOnHandler, {
          arg velocity,  number, channel, source;
          ~notes[number] = Synth.new(\testSynth,
                                     [\freq, number.midicps, \amp, velocity.linexp(1, 127, 0.01, 0.03), \gate, 1]);
      });
  MIDIdef.noteOff(\noteOffHandler, {
          arg velocity, number;
          ~notes[number].set(\gate, 0);
          ~notes[number] = nil;
      });

  MIDIdef.bend(\bendTest, {
          arg vel, num, src;
          ~bend = vel;
          ~notes.do{arg synth; synth.set(\bend, vel.linlin(0.16383, -2, 2))};
      });
  ~bend = 8912;
  SynthDef.new(\testSynth, {
          {
              arg freq = 440, amp = 0.3, gate = 0;
              var sig, env;
              sig = LFTri.ar(freq)!2;
              env = EnvGen.kr(Env.adsr, gate, doneAction: 2);
              sig = sig * env * amp;
              Out.ar(0, sig);
          }).add;
#+END_SRC


** Buses
In.ar(num) reads from bus number 1

Bus.audio(s, num) allocates a bus with num channels
e.g. ~myBus = Bus.audio(s, 2);
x = Synth.new(\reverb, [\in, ~myBus]);
#+BEGIN_SRC java
    (
    SynthDef.new(\blip, {
            arg out;
            var freq, trig, sig;
            freq = LFNoise0.kr(3).exprange(300, 1200).round(300);
            sig = SinOsc.ar(freq) * 0.25;
            trig = Dust.kr(2);
            sig = sig * EnvGen.kr(Env.perc(0.01, 0.2), trig);
            Out.ar(out, sig);

    }).add;

    SynthDef.new(\reverb, {
            arg in, out=0;
            var sig;
            sig = In.ar(in, 1);  // 1, here monophonic
            sig = FreeVerb.ar(sig, 0.5, 0.8, 0.2)!2;  // !2 for 2 channels
            Out.ar(out, sig);
    }).add;
    )
  ~reverbBus = Bus.audio(s, 2);
  Synth.new(\reverb, [\in, ~reverbBus]);
  Synth.new(\blip, [\out, ~reverbBus]);


  // also specify which group (s, default group)
  // in this example it doesn't make a different which line is run first.
  // because reverb is added to tail, it will always have audio incoming.
  y = Synth.new(\reverb, [\in, ~reverbBus], s, \addToTail);
  x = Synth.new(\blip, [\out, ~reverbBus], s);
  x.free;
  y.free;

  // another way to place these synths in order is to specify which Synth
  // we want to place the effect after. we add reverb after blip (x) synth.
  x = Synth.new(\blip, [\out, ~reverbBus], s);
  y = Synth.new(\reverb, [\in, ~reverbBus], x, \addAfter); // see x

  // 5 convenience methods for addAction: (work for Synth and Group)
  // \addToHead, \addToTail, \addAfter, \addBefore, \addReplace
  // can be written as
  Synth.after(\reverb, [\in, ~reverbBus], x);
  Synth.before(...);
  Synth.head(...);
  Synth.tail(\reverb, [\in, ~reverbBus], s,);
  Synth.replace(...);

  ~sourceGroup = Group.new;
  ~fxGroup = Group.after(~sourceGroup);

  /////
  ///// adding arguments to the blip synth, unnamed synths added to group
  ///// (unnamed instances of \blip synth)

  ~sourceGroup = Group.new;
  ~fxGroup = Group.after(~sourceGroup);
  ~reverbBus2 = Bus.audio(s, 2);  //stereo. belongs to local server s
  y = Synth.new(\reverb, [\in, ~reverbBus2], ~fxGroup);

  ~sourceGrp.set(....) //Send arguments for all nodes in group
#+END_SRC

** Frequency Modulation
Frequency, Amplitude modulation can produce sidebands of frequencies which are result of additive, subtractive interference of carrier and modulating frequencies
Index controls how much the modulating signal pushes the carrier (strength of modulator?) and therefore how many sidebands are created


   #+BEGIN_SRC sclang
     {PMOsc.ar(1000, 1367, 12, mul: EnvGen.kr(Env.perc(0, 0.5), Impulse.kr(1)))}.play

     (
     {
             Mix.ar(
                     SinOsc.ar(abs((-20..20)*1367 + 1000),
                             mul: 0.1*EnvGen.kr(Env.perc(0, 0.5), Impulse.kr(1)))
             )}.play
     )
   #+END_SRC

* Emacs
You can run the command `paredit-forward-slurp-sexp' with M-)
You can run the command `paredit-backward-slurp-sexp' with C-M-s
You can run the command `paredit-backward-barf-sexp' with C-M-e
You can run the command `paredit-forward-barf-sexp' with C-M-y
